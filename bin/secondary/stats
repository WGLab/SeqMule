#!/usr/bin/env perl

#Copyright (C) <2012>  <Yunfei Guo>

##This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

##This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

##You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.


use warnings;
use strict;
use FindBin qw/$RealBin/;
use File::Spec;
use File::Basename qw/basename dirname/;
use lib File::Spec->catdir($RealBin,"..","..","lib");
use SeqMule::Utils;
use Cwd qw/abs_path/;
use Pod::Usage qw/pod2usage/;
use Getopt::Long qw/GetOptions/;

####################CONSTANT#######################
my $ARGCOUNT=100000; #number of regions to extract using command line, max number if restricted by kernel config
my $INDEL_EXTENSION = 10; #when determining indel overlapping, interalize indels by extending indel INDEL_EXTENSION bp towards both ends
my $TMPDIR = $ENV{TMPDIR} || "/tmp";
my %LEGAL_VAR_FILETYPE = (
    'avinput'	=>	1,
    'vcf'	=>	1,
    'consensus'	=>	1,
    'vcf.gz'	=>	1,
);
##################################################
my ($prefix,
    $bam,$vcf,
    $buildver,$capture,
    $venn,$aln,
    $ref,$minN,$consensus_vcf,$union_vcf,$consensus_files,$union_files,
    $plink,$paternal_id,$maternal_id,$mendelian_stat,
    $sample,$nofilter,
    $jmem,$jexe,$nt,$tmpdir,
    $help,$noclean,$verbose,
);
my $install_dir=File::Spec->catdir($RealBin,"..","..");
my @gunlink;
my %loc; #exe locations, used for speeding exe search


@ARGV or pod2usage ({-exitval=>2});
GetOptions(
    'prefix|p=s'	=>	\$prefix,
    'bam=s'		=>	\$bam,
    'vcf=s'		=>	\$vcf,
    'aln'		=>	\$aln,
    'capture:s'	        =>	\$capture,
    'sample|s=s'	=>	\$sample,
    'nofilter'		=>	\$nofilter,

    'consensus|c=s'     =>      \$consensus_files,
    'union|u=s'		=>	\$union_files,

    'ref=s'		=>	\$ref,
    'c-vcf=s'		=>	\$consensus_vcf,
    'N=i'		=>	\$minN,
    'u-vcf=s'		=>	\$union_vcf,
    'plink'		=>	\$plink,
    'mendel-stat'	=>	\$mendelian_stat,
    'paternal=s'	=>	\$paternal_id,
    'maternal=s'	=>	\$maternal_id,
    'jmem=s'		=>	\$jmem,
    'jexe=s'		=>	\$jexe,
    't=i'		=>	\$nt,
    'tmpdir=s'		=>	\$tmpdir,

    'venn=s'		=>	\$venn,

    'help|h'	        =>	\$help,
    'noclean'		=>	\$noclean,
    'verbose|v'		=>	\$verbose,
) or pod2usage({-exitval => 2});
$help and pod2usage ({-verbose=>2});

#option check
die "ERROR:No prefix while multiple input files are used!\n" if ( ($consensus_files || $union_files || $venn || $consensus_vcf || $union_vcf ) && !$prefix);
die "ERROR:Please supply a sorted BAM file (-bam)\n" if (defined $aln && ! $bam );
die "ERROR:Please supply a sorted BAM file (-bam) or VCF file (-vcf)\n" if (defined $capture && ! ( $bam or $vcf));
die "ERROR:Please specify at least 2 VCF, AVINPUT or SOAPsnp files (-c)\n" if ($consensus_files && $consensus_files=~s/,/,/g < 1);
die "ERROR:Please specify at least 2 VCF, AVINPUT or SOAPsnp files (-u)\n" if ($union_files && $union_files=~s/,/,/g < 1);
die "ERROR:Please specify at least 2 VCF, AVINPUT or SOAPsnp files (-venn)\n" if ($venn && $venn=~s/,/,/g < 1);
die "ERROR:Please specify at least 2 VCF files (-u-vcf)\n" if ($union_vcf && $union_vcf=~s/,/,/g < 1);
die "ERROR:Please specify at least 2 VCF files (-c-vcf)\n" if ($consensus_vcf && $consensus_vcf=~s/,/,/g < 1);
die "ERROR:No reference file specified or found. Use --ref option.\n" if ( ($venn || $union_vcf || $consensus_vcf) && ! ($ref && -f $ref));
die "ERROR:--vcf and --plink must be used together.\n" if ($plink && !$vcf);
die "ERROR:--paternal and --maternal must be used together\n" if ($paternal_id && !$maternal_id or !$paternal_id && $maternal_id);
die "ERROR:--mendel-stat must be used with --plink\n" if ($mendelian_stat && !$plink or !$mendelian_stat && $plink);
die "ERROR:Please use -capture or -aln option with -bam\n" if (defined $bam && ! ($aln or $capture) );

#set default
$jmem=$jmem||'1750m';
$jexe = $jexe || 'java';
$nt=$nt || 1;
$tmpdir = $tmpdir || $TMPDIR;

if ($union_vcf)
{
    &vcf_union(split /,/,$union_vcf);
}

if ($consensus_vcf)
{
    &vcf_consensus(split /,/,$consensus_vcf);
}

if ($union_files)
{
    &var_union(
	&conv2anno(split /,/,$union_files) );
}

if ($consensus_files) {
    &var_consensus(
	&conv2anno(split /,/,$consensus_files) 
    );
}

if ($venn) {
    my @files=split /,/,$venn;
    &SeqMule::Utils::checkFileType(\%LEGAL_VAR_FILETYPE,1,@files);

    if(&SeqMule::Utils::getSuffix($files[0]) =~ /^vcf$|^vcf\.gz$/) {
	@files=&SeqMule::Utils::getNonEmptyVCF(@files);
	&venn( \@files,&conv2anno(&normalize_vcf(@files)) );
    } else {
	&venn( \@files,&conv2anno(@files) );
    }
}

if (defined $capture) 
{
    if ($bam)
    {
	my $stat_output = &coverage_stat($capture,$bam) 
	    or die "Unable to calculate coverage statistics\n";
	&coverage_plot($stat_output);
    }
    if ($capture && $vcf)
    {
	#stats will be generated for extracted VCF
	$vcf=&extractVar($capture,$vcf);
    }
}

&aln_stat($bam) if ($bam && $aln);

if (defined $vcf)
{
    if (defined $sample)
    {
	&var_stat($vcf,$sample);
    } else
    {
	&var_stat($vcf);
    }

    my ($ped,$map);
    if ($plink)
    {
	#convert VCF to PLINK format
	my $result = &vcf2plink({vcf=>$vcf,paternal_id=>$paternal_id,maternal_id=>$maternal_id});
	$ped = $result->{ped};
	$map = $result->{map};
    }
    if ($mendelian_stat)
    {
	warn "\n\n" and 
	warn "WARNING: no paternal or maternal ID is specified, 
	not all Mendelian statistics will generated.\n" and
	warn "\n\n"
	if (!$paternal_id or !$maternal_id);
	&gen_mendelian_stat({ped=>$ped,map=>$map});
    }
}


END { &clean_up()}

#SIGINT handler

$SIG{INT}='clean_up';
######################SUBROUTINES############################    
sub gen_mendelian_stat
{
    my $opt = shift;
    my $ped = $opt->{ped};
    my $map = $opt->{map};
    die "ERROR: no PED or MAP input for generating Mendelian error statistics\n" unless $ped && $map;
    my $local_prefix=&getPrefix($ped);
    my $outfile="${local_prefix}_mendel_stat.txt";
    my $mendelfix=&getExe("mendelfix");
    my $tmp = File::Spec->catfile($tmpdir,$$.rand($$).".mendelfix");
    my $mendelfix_stats = "$tmp.stats";
    my $mendelfix_pmiss = "$tmp.pmiss";
    my $mendelfix_ped = "$tmp.ped";
    my $mendelfix_map = "$tmp.map";

    push @gunlink,$mendelfix_stats,$mendelfix_pmiss,$mendelfix_ped,$mendelfix_map;
    !system("$mendelfix $ped $map $tmp 1>/dev/null") or die "ERROR: failed to run mendelFix\n";

    my %explanation = (
	ID		=> "Offspring ID",
	NCALL1		=> "Total number of loci in input",
	CR1		=> "Proportion of non-missing genotypes in all loci",
	FATHER		=> "Father ID",
	FOCALL		=> "Number of calls in both father and offspring",
	FOIBS0		=> "Number of variants with 0 IBS allele between father and offspring",
	FOIBS1		=> "Number of variants with 1 IBS allele between father and offspring",
	FOIBS2		=> "Number of variants with 2 IBS alleles between father and offspring",
	FOERROR		=> "Proportion of variants with 0 IBS allele in calls shared by father and offspring (Mendelian error)",
	MOTHER		=> "Mother ID",
	MOCALL		=> "Number of calls in both mother and offspring",
	MOIBS0		=> "Number of variants with 0 IBS allele between mother and offspring",
	MOIBS1		=> "Number of variants with 1 IBS allele between mother and offspring",
	MOIBS2		=> "Number of variants with 2 IBS alleles between mother and offspring",
	MOERROR		=> "Proportion of variants with 0 IBS allele in calls shared by mother and offspring (Mendelian error)",
	TRIOCALL	=> "Number of calls in both parents and all offsprings",
	ADI		=> "Number of allele drop in (offspring presents an allele which doesn't appear in parents)",
	PADI		=> "Proportion of allele drop in among all calls shared by this family",
	ADO		=> "Number of allele drop out (offspring misses an allele which should have been inherited from parents)",
	PADO		=> "Proportion of allele drop out among all calls shared by this family",
	NERROR		=> "Number of Mendelian errors (sum of allele drop in and out)",
	PPCERROR	=> "Proportion of Mendelian errors in all calls shared by this family",
	#NFIX		=> "Number of genotypes that can be inferred using parents information",
	#NCALL2		=> "Number of loci after fixing genotypes",
	#CR2		=> "Proportion of non-missing genotypes in all loci after fixing genotypes",
    );

    open OUT,'>',$outfile or die "ERROR: failed to write to $outfile ($!)\n";
    my %stat = %{&SeqMule::Utils::parseMendelFix($mendelfix_stats)};
    print OUT "$outfile=Mendelian error stats\n";
    for my $id(sort keys %stat)
    {
	for my $j(
	    qw(ID NCALL1 CR1 FATHER FOCALL FOIBS0 FOIBS1 FOIBS2 FOERROR MOTHER MOCALL MOIBS0 MOIBS1 MOIBS2 MOERROR TRIOCALL ADI PADI ADO PADO NERROR PPCERROR
	))
	{
	    print OUT "$explanation{$j}=$stat{$id}{$j}\n" if $explanation{$j} && $stat{$id}{$j};
	}
	print OUT "\n" if defined $stat{$id};
    }
    close OUT;
    warn "NOTICE: Mendelian error statistics written to $outfile\n";
}
sub vcf2plink
{
    #test case
    #stats -vcf 1.vcf --plink
    #stats --plink
    #stats --vcf 1.vcf --plink -paternal father
    #stats --vcf 1.vcf --plink -maternal mother
    #stats --vcf 1.vcf --plink -maternal mother -paternal father
    my $opt = shift;
    my $vcf = $opt->{vcf};
    my $paternal_id = $opt->{paternal_id};
    my $maternal_id = $opt->{maternal_id};
    my $local_prefix=&getPrefix($vcf);
    my $ped = "$local_prefix.ped";
    my $map = "$local_prefix.map";
    my $vcftools=&getExe("vcftools");
    my $tmp = File::Spec->catfile($tmpdir,$$.rand($$).".ped.tmp");
    push @gunlink,$tmp;

    if ($paternal_id && $maternal_id)
    {
        my @sample_in_vcf=&SeqMule::Utils::getVCFSample($vcf);
	die "ERROR: at least 3 samples are expected in $vcf\n" unless @sample_in_vcf >= 3;
    }

    warn "WARNING: no paternal or maternal ID is provided. Continue anyway ...\n" unless ($paternal_id || $maternal_id);

    unless ($nofilter)
    {
	$vcf = &rm_filtered_var_from_vcf($vcf);
    }
    !system("$vcftools --vcf $vcf --plink ".($nofilter? "":"--remove-filtered-all")." --out $local_prefix 2>/dev/null") or 
    die "ERROR: failed to convert $vcf to PLINK format with VCFtools ($!).\n";

    if ($paternal_id && $maternal_id)
    {
	my $new_family_id = "Family".($paternal_id?"_$paternal_id":"").($maternal_id?"_$maternal_id":"");
	my $fa_present = 0;
	my $ma_present = 0;
	#modify paternal ID, maternal ID, family ID, Sex (1=male; 2=female)
	open IN,'<',$ped or die "ERROR: failed to open $ped ($!)\n";
	open OUT,'>',$tmp or die "ERROR: failed to write to $tmp ($!)\n";
	while(<IN>)
	{
	    #format
	    #Family_ID	Individual_ID	Paternal_ID	Maternal_ID	Sex	Phenotype	Genotype...
	    #father	father	0	0	0	0	G	G	A	A	
	    #mother	mother	0	0	0	0	G	G	A	C
	    #son	son	0	0	0	0	G	G	A	A
	    my ($fam,$individual,$p,$m,$sex);
	    my @other;
	    ($fam,$individual,$p,$m,$sex,@other) = split;
	    $fam = $new_family_id;
	    if ($individual ne $paternal_id && $individual ne $maternal_id)
	    {#not father,not mother
		$p = $paternal_id;
		$m = $maternal_id;
	    } elsif($individual eq $paternal_id)
	    {#not mother, but father
		$sex = 1;
		$p = 0;
		$m = 0;
		$fa_present = 1;
	    } elsif ($individual eq $maternal_id)
	    {#not father, but mother
		$sex = 2;
		$p = 0;
		$m = 0;
		$ma_present = 1;
	    } else
	    {
		#father, mother???
		die "ERROR: paternal ID and maternal ID are the same!\n";
	    }
	print OUT join(" ",($fam,$individual,$p,$m,$sex,@other)),"\n";
	}
	die "ERROR: $paternal_id or $maternal_id is missing.\n" unless ($fa_present && $ma_present);
    close IN;
    close OUT;
    !system("mv -f $tmp $ped") or die "ERROR: failed to rename $tmp to $ped ($!)\n";
    }
    warn "NOTICE: PLINK format output written to $ped and $map\n";
    return {ped=>$ped,map=>$map};
}
sub vcf_consensus
{
    my @in=@_;
    die "At least 2 VCF files for extracting consensus calls\n" unless @in>1;
    my $out=&getPrefix(@in)."_consensus.".(defined $sample?"$sample.":"")."vcf";
    my @local_sample;
    my $local_minN=$minN || scalar @in;

    my ($unzipped,$unlink)=&SeqMule::Utils::gunzip(@in);
    @in=@$unzipped;
    push @gunlink,@$unlink;

    #remove filtered variants
    unless ($nofilter)
    {
	@in = map { &rm_filtered_var_from_vcf($_) } @in;
    }

    @local_sample = &figure_out_vcf_sample(@in);

    &run_gatk_combine_var({
	    vcf=>[@in],
	    sample=>[@local_sample],
	    minN=>$local_minN,
	    out=>$out,
	});
    my $var_num=`grep -v '#' $out|wc -l`;
    chomp $var_num;
    warn "NOTICE: $var_num variants written to $out.\n";
}
sub vcf_union
{
    my @in=@_;
    die "At least 2 VCF files for extracting union calls\n" unless @in>1;
    my $out=&getPrefix(@in)."_union.".(defined $sample?"$sample.":"")."vcf";
    my @local_sample;

    my ($unzipped,$unlink)=&SeqMule::Utils::gunzip(@in);
    @in=@$unzipped;
    push @gunlink,@$unlink;

    unless ($nofilter)
    {
	@in = map { &rm_filtered_var_from_vcf($_) } @in;
    }

    @local_sample = &figure_out_vcf_sample(@in);
    &run_gatk_combine_var({
	    vcf=>[@in],
	    sample=>[@local_sample],
	    minN=>1,
	    out=>$out,
	});
    my $var_num=`grep -v '#' $out|wc -l`;
    chomp $var_num;
    warn "NOTICE: $var_num variants written to $out.\n";
}
sub figure_out_vcf_sample
{
    my @in = @_;
    my @local_sample;
    if(defined $sample)
    {
	push @local_sample,$sample;
    } else
    {
	#samples in each VCF must be the same 
	for my $i(@in)
	{
	    if(@local_sample)
	    {
		my %seen;
		my @current_sample_list = &SeqMule::Utils::getVCFSample($i);
		die "ERROR: not all VCFs have the same number of samples!\n"
		if @local_sample != @current_sample_list;
		for my $j(@local_sample)
		{
		    $seen{$j}=1;
		}
		for my $j(@current_sample_list)
		{
		    die "ERROR: not all VCFs have the same set of samples (case-sensitive)!\n"
		    unless $seen{$j};
		}
	    } else
	    {
		@local_sample = &SeqMule::Utils::getVCFSample($i);
	    }
	}
    }
    return @local_sample;
}
sub run_gatk_combine_var
{
    my $arg = shift;
    my @vcf = @{$arg->{vcf}};
    my @sample = @{$arg->{sample}};
    my $minN = $arg->{minN};
    my $out = $arg->{out};
    my @per_sample_combo_vcf_list;
    my $gatk=&getExe(&SeqMule::Utils::getProgramExe("gatklite"),&SeqMule::Utils::getProgramExe("gatk"));

    for my $sample(@sample)
    {
	my @per_sample_vcf = @vcf;
	for my $local_vcf(@per_sample_vcf)
	{
	    my $local_out = File::Spec->catfile($tmpdir,$sample.$$.rand($$).".".(basename $local_vcf));
	    !system("$jexe -Xmx$jmem -jar $gatk -T SelectVariants -R $ref -sn $sample -V $local_vcf -o $local_out -U LENIENT_VCF_PROCESSING -l INFO ") or die "ERROR: Failed to split VCF by sample\n";
	    my $local_out_nomissing = File::Spec->catfile($tmpdir,$sample.$$.rand($$).".".(basename $local_vcf));
	    #records with missing genotype cannot be handled correctly
	    !system("grep -v '\\.\\/\\.' $local_out > $local_out_nomissing") or die "ERROR: failed to generate single-sample VCF that doesn't missing genotypes ($!).\n";
	    $local_vcf=$local_out_nomissing;
	    push @gunlink,$local_out,$local_out_nomissing;
	}
	#before combine single-sample VCF
	#consider add normalization here, so that we don't have to deal with multi-genotype issue
	@per_sample_vcf = &normalize_vcf(@per_sample_vcf);
	
	my $per_sample_combo_vcf = File::Spec->catfile($tmpdir,$$.rand($$)."per_sample_combo.vcf");
	my $cmd =
	"$jexe -Xmx$jmem -jar $gatk -T CombineVariants".
	" -R $ref".
	" -nt $nt".
	" -l ERROR".
	" -U LENIENT_VCF_PROCESSING".
	" -o $per_sample_combo_vcf";
	if ($nofilter)
	{
	    $cmd.=" -filteredRecordsMergeType KEEP_UNCONDITIONAL";
	    warn "NOTICE: keep all variants regardless whether they are filtered or not.\n";
	} else
	{
	    $cmd.=" -filteredRecordsMergeType KEEP_IF_ALL_UNFILTERED";
	    #$cmd.=" -filteredRecordsMergeType KEEP_IF_ANY_UNFILTERED";
	    warn "NOTICE: keep variants if they are unfiltered in any one of the input files.\n";
	}

	$cmd.=" -minN $minN" and
	warn "NOTICE: extracting variants shared by at least $minN input files.\n" if defined $minN && $minN > 1;
	map {$cmd.=" -V:".(basename $_).",VCF $_ "} @per_sample_vcf;

	!system($cmd) or die "Failed to merge VCF files\n";
	push @per_sample_combo_vcf_list,$per_sample_combo_vcf;
    }
    my $cmd = 
    "$jexe -Xmx$jmem -jar $gatk -T CombineVariants".
    " -R $ref".
    " -nt $nt".
    " -l ERROR".
    " -U LENIENT_VCF_PROCESSING".
    " -o $out";
    map {$cmd.=" -V $_ "} @per_sample_combo_vcf_list;

    !system($cmd) or die "Failed to merge per-sample VCF files\n";
    return $out;
}
sub extractVar
{
    my ($bed,$vcf)=@_;
    my $header=`grep '#' $vcf`;
    my $local_prefix=&getPrefix($vcf);
    my $outfile="${local_prefix}.extract.vcf";
    my $gzvcf="$vcf.gz"; 
    my $bgzip=&getExe(&SeqMule::Utils::getProgramExe("bgzip"));
    my $tabix=&getExe(&SeqMule::Utils::getProgramExe("tabix"));

    #convert bed regions to tabix arguments
    warn "Extracting variants based on specified BED file.\n";
    !system("$bgzip -c $vcf > $gzvcf") and 
    !system("$tabix -p vcf $gzvcf") or die "Can't compress and index $vcf: $!\n"; 
    !system("$tabix -f $gzvcf -h -B $bed > $outfile") or die "ERROR: Failed to extract variants from $vcf: $!\n";
    my $varcount=`grep -v '#' $outfile | wc -l `;chomp $varcount; $varcount=~s/^(\d+)\s.*/$1/;
    warn "NOTICE: $varcount extracted variants written to $outfile\n";

    return $outfile;
}

sub aln_stat
{
    my $bam=shift;
    my $tmp=File::Spec->catfile($tmpdir,"seqmule.$$".rand($$).".primaryonly.bam");
    my $samtool=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_prefix=&getPrefix($bam);
    my $outfile="${local_prefix}_aln_stat.txt";
    my $output;

    warn "NOTICE: Extracting primary alignments\n";
    !system("$samtool view -@ $nt -F 256 -b $bam > $tmp") or die "Failed to extract primary alignments.\n";

    warn "Generating alignment stats\n";
    open IN,'-|',"$samtool flagstat $tmp" or die "Can't read samtools output: $!\n";
    $output.="$bam=Alignment stats\n";
    while(<IN>)
    {
	$output.="QC-passed reads=$1\nQC-failed-reads=$2\n" if /(\d+) \+ (\d+) in total \(QC-passed reads \+ QC-failed reads\)/;
	$output.="Duplicates=$1\n" if /(\d+) \+ \d+ duplicates/; 
	$output.="Mapped reads=$1($2)\n" if /(\d+) \+ \d+ mapped \((.*?%):.*\)/;
	$output.= "Paired reads=$1\n" if /(\d+) \+ \d+ paired in sequencing/;
	$output.= "Read1=$1\n" if /(\d+) \+ \d+ read1/;
	$output.="Read2=$1\n" if /(\d+) \+ \d+ read2/;
	$output.= "Properly paired=$1($2)\n" if /(\d+) \+ \d+ properly paired \((.*?%):.*\)/;
	$output.= "Reads with itself and mate mapped=$1\n" if /(\d+) \+ \d+ with itself and mate mapped/;
	$output.= "Singletons=$1($2)\n" if /(\d+) \+ \d+ singletons \((.*?%):.*\)/;
	$output.= "Reads with mate mapped to a different chromosome=$1\n" if /(\d+) \+ \d+ with mate mapped to a different chr$/;
	$output.= "Reads with mate mapped to a different chr (mapQ at least 5)=$1\n" if /(\d+) \+ \d+ with mate mapped to a different chr \(mapQ>=5\)$/;
    }
    close IN;

    push @gunlink,$tmp;
    #write to output
    &SeqMule::Utils::write2outfile($output,$outfile);
    warn "Output written to $outfile\n";
}

sub var_stat
{
    my $original_vcf=shift;
    my $local_vcf=$original_vcf;
    my $sample=shift;
    my $local_prefix=&getPrefix($local_vcf);
    my $outfile="${local_prefix}_var_stat.txt";
    my $vcftools=&getExe("vcf-stats");
    my $dump;
    my $output;
    my @sample_in_vcf=&SeqMule::Utils::getVCFSample($local_vcf);
    my $error_tmp = File::Spec->catfile($tmpdir,rand($$).".tmp.err");

    if (! defined $sample)
    {
	warn "NOTICE: Multiple samples in VCF, please specify sample name (-s) if you only need stats from a specific sample (does not influence Mendelian stats).\n" if @sample_in_vcf>1;
    } else
    {
	die "$sample NOT found in VCF\n" if (grep { $_ eq $sample} @sample_in_vcf) == 0;
	die "$sample duplicates in VCF\n" if (grep { $_ eq $sample} @sample_in_vcf) > 1;
    }

    warn "Generating variant stats\n";
    &loadPM($vcftools);
    unless ($nofilter)
    {
	#only consider variants with 'PASS' or '.' in FILTER
	my $tmp=File::Spec->catfile($tmpdir,"$$.filtered.vcf");
	!system("perl -ne '\@f=split /\\t/; print if /^#/ or \$f[6] eq \"PASS\" or \$f[6] eq \".\";' $local_vcf > $tmp")
	    or die "Failed to output filtered variants: $!\n";
	$local_vcf=$tmp;
    }
    if (defined $sample)
    {
	$dump=`$vcftools $local_vcf -s $sample 2>$error_tmp` or die "Cannot read output from vcf-stats: ",`cat $error_tmp`,"\n";
    } else
    {
	$dump=`$vcftools $local_vcf 2>$error_tmp` or die "Cannot read output from vcf-stats: ",`cat $error_tmp`,"\n";
    }

    if (0)
    { #example output
	my $VAR1 = {
	    'samples' => {
		'father' => {
		    'hom_AA_count' => 97282, #1/1,2/2 variant
		    'indel_count' => 6057,
		    'indel' => {
			'-13' => 11,
			'5' => 78,
			#ignore some lines
		    },
		    'het_RA_count' => 47435, #0/1 variant
		    'snp_count' => 138743, #number of SNPs
		    'count' => 162826, #snp+indel
		    'hom_RR_count' => 18026, #0/0 non-mutation
		    'ref' => 65461,
		    'private' => 144800, #snp_count+indel_count-shared_variant
		    'missing' => 50070,
		    'het_AA_count' => 83, #1/2,1/3 etc., variant
		    'snp' => {
			'A>C' => 5648,
			'A>G' => 24308, #ti
			'T>G' => 5694,
			'T>A' => 3587,
			'T>C' => 24096, #ti
			'C>T' => 23792, #ti
			'C>A' => 5222,
			'A>T' => 3600,
			'G>T' => 5301,
			'C>G' => 6885,
			'G>C' => 6765,
			'G>A' => 23859 #ti
		    },
		    'unphased' => 162826,
		    'ref_count' => 65461
		}
	    },
	    'all' => {
		'indel_count' => 6863,
		'indel' => {
		    '-13' => 13,
		    '5' => 90
		    #ignore some lines
		},
		'snp_count' => 206033,
		'count' => 212896,
		'nalt_1' => 212763,
		'shared' => {
		    '1' => 144800,
		    '0' => 68096
		},
		'nalt_2' => 132,
		'snp' => {
		    'A>C' => 8268,
		    'A>G' => 35693,
		    'T>G' => 8306,
		    'T>A' => 5287,
		    'C>T' => 35659,
		    'T>C' => 35731,
		    'C>A' => 7870,
		    'A>T' => 5463,
		    'G>T' => 7841,
		    'C>G' => 10121,
		    'G>C' => 10001,
		    'G>A' => 35826
		},
		'nalt_3' => 1
	    }
	};
    }
    $dump.='%sample_hash= %{$$VAR1{samples}};'."\n";
    $dump.='@sample=keys %sample_hash;'."\n";
    $dump.='for my $sample(@sample) {'."\n";
    $dump.='%sample_stat= %{$sample_hash{$sample}};'."\n";
    $dump.='$nsnp=$sample_stat{snp_count} if exists $sample_stat{snp_count};'."\n";
    $dump.='$nindel=$sample_stat{indel_count} if exists $sample_stat{indel_count};'."\n";
    $dump.='$total=$nsnp+$nindel if defined $nsnp && defined $nindel;'."\n";
    $dump.='$nti=0;map {$nti+=${$sample_stat{snp}}{$_} if exists ${$sample_stat{snp}}{$_} } qw(A>G G>A C>T T>C);'."\n";
    $dump.='$ntv=0;map {$ntv+=${$sample_stat{snp}}{$_} if exists ${$sample_stat{snp}}{$_} } qw(A>C C>A G>T T>G A>T T>A C>G G>C);'."\n";
    $dump.='$titv= $ntv ? $nti/$ntv : 0;'."\n";
    $dump.='$titv= sprintf "%.2f",$titv;'."\n";
    $dump.='$nhet_RA=$sample_stat{het_RA_count} if exists $sample_stat{het_RA_count};'."\n";
    $dump.='$nhet_AA=$sample_stat{het_AA_count} if exists $sample_stat{het_AA_count};'."\n";
    $dump.='$nhet=$sample_stat{het_AA_count}+$sample_stat{het_RA_count} if exists $sample_stat{het_AA_count} && exists $sample_stat{het_RA_count};'."\n";
    $dump.='$nhom=$sample_stat{hom_AA_count} if exists $sample_stat{hom_AA_count};'."\n";


    $dump.="print 'Sample='.(\$sample).\"\\n\" if defined \$sample;\n";
    $dump.="print 'Number of variants='.(\$total).\"\\n\" if defined \$total;\n";
    $dump.="print 'Number of SNVs='.(\$nsnp).\"\\n\" if defined \$nsnp;\n";
    $dump.="print 'Number of indels='.(\$nindel).\"\\n\" if defined \$nindel;\n";
    $dump.="print 'Transitions='.(\$nti).\"\\n\" if defined \$nti;\n";
    $dump.="print 'Transversions='.(\$ntv).\"\\n\" if defined \$ntv;\n";
    $dump.="print 'Ti/Tv Ratio='.(\$titv).\"\\n\" if defined \$titv;\n";
    $dump.="print 'Total heterozygotes='.(\$nhet).\"\\n\" if defined \$nhet;\n";
    $dump.="print 'Ref/Alt heterozygotes='.(\$nhet_RA).\"\\n\" if defined \$nhet_RA;\n";
    $dump.="print 'Alt/Alt heterozygotes='.(\$nhet_AA).\"\\n\" if defined \$nhet_AA;\n";
    $dump.="print 'Homozygotes='.(\$nhom).\"\\n\" if defined \$nhom;\n";
    $dump.="}\n";

    my $tmp_script=File::Spec->catfile($tmpdir,"$$.seqmule.varstat");
    open SCRIPT,'>',$tmp_script or die "Failed to write to $tmp_script: $!\n";
    print SCRIPT $dump;
    close SCRIPT;

    open IN,'-|',"$^X $tmp_script 2>/dev/null" or die "Failed to read from vcf-stats dump: $!\n";
    $output.="$original_vcf=Variant stats".($nofilter? '':'(filter applied)')."\n";
    while(<IN>)
    {
	$output.=$_;
    }
    close IN;
    &SeqMule::Utils::write2outfile($output,$outfile);
    warn "NOTICE: Output written to $outfile\n";
}



sub clean_up 
{
    warn "NOTICE: Cleaning...\n" and unlink @gunlink if (@gunlink && !$noclean);
}

sub coverage_plot
{
    my $stat_file=shift;
    my $n=3; #skip non-coverage lines
    my $lines;
    my $r="Rscript";

    return undef unless $stat_file;
    warn "$stat_file missing\n" and return undef unless -f $stat_file;

    $lines=`wc -l $stat_file`;
    chomp $lines;
    $lines=~s/^(\d+).*/$1/;
    unless ($lines>$n)
    {
	warn "WARNING: No coverage statistics: too few alignments or too small region?\n";
	return undef;
    }

    my $source=File::Spec->catfile($tmpdir,"$$".rand($$).".coverage_plot.script");
    my $local_prefix=&getPrefix($bam);
    my $jpg="${local_prefix}_cov.jpg";
    my $code=#skip first N lines
    "x=read.table(\"$stat_file\",skip=$n,sep=\" \")
    x\$V9=sub('<0.01%','0',x\$V9)
    x\$V9=as.numeric(sub('%','',x\$V9))/100
    coverage=subset(x,select=c(3,9))
    names(coverage)=c(\"Coverage\",\"Cumulative fraction\")
    width = 5
    height = 10

    xlim = c(max(coverage[[1]]),1)
    ylim = c(0,1)
    xtick.pos = c(10000,1000,100,20,10,5,1)
    ytick.pos = c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)

    length_above01 = length(coverage[[1]][coverage[[2]]>=0.1])
    xlim2 = ylim2 = ytick.pos2 = NULL
    #take care of the situation where reads cover <10% of region
    if(length_above01>0) {
    xlim2 = c(max(coverage[[1]][coverage[[2]]>=0.1]),1)
    ylim2 = c(0.1,1)
    ytick.pos2 = c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)
    ##make room for 2nd plot
    #height = 10
    }


    jpeg(\"$jpg\",width=width,height=height,units='in',res=500)
    #if(length_above01>0) {
    par(mfrow = c(2,1))
    #}
    suppressWarnings(plot(coverage,log=\'x\',pch=1,col=\'blue\',xlim=xlim,ylim=ylim,axes=FALSE))
    axis(side=1,at=xtick.pos)
    axis(side=2,at=ytick.pos)
    box()
    if(length_above01>0) {
    suppressWarnings(plot(coverage,log=\'x\',pch=1,col=\'blue\',xlim=xlim2,ylim=ylim2,axes=FALSE))
    axis(side=1,at=xtick.pos)
    axis(side=2,at=ytick.pos2)
    box()
    }
    garbage <- dev.off()
    ";
    &SeqMule::Utils::write2outfile($code,$source);
    system ("$r --vanilla $source 1>&2");
    warn "ERROR: Failed to plot $stat_file" and return undef if $?;
    warn "NOTICE: coverage plot <<$jpg>> generated\n";
    push @gunlink,$source;
}

#summary statistics
sub coverage_stat 
{
    my $cap_region=shift;
    my $file=shift;
    my $local_prefix=&getPrefix($file);
    my $cap_out="${local_prefix}_cov_stat.txt";
    my $cap_out_detail="${local_prefix}_cov_stat_detail.txt";
    my $exe=&getExe("cal_genome_enrichment.pl");
    my $exe_samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));

    warn "NOTICE: Calculating coverage for $file. This takes a while\n";
    ! system ("$^X $exe $exe_samtools $file $cap_region > $cap_out_detail") or die "Failed to caculate coverage stat for $file\n";

    open IN,'<',$cap_out_detail or die "Can't open $cap_out_detail: $!\n";
    open OUT,'>',$cap_out or die "Can't write to $cap_out: $!\n";
    print OUT "$file=Coverage stats\n";
    while(<IN>)
    {
	print OUT $_ if /fraction/i;
	print OUT $_ if /total length/i;
	print OUT $_ if /coverage stats/i;
	print OUT $_ if /average/i;
	print OUT "Percentage above 5=$2\n" if (/coverage\s+=\s+(\d+).*?cum_frac\s+=\s+(<?\s*\d+\.?\d*%)/i && $1 == 5);
	print OUT "Percentage above 10=$2\n" if (/coverage\s+=\s+(\d+).*?cum_frac\s+=\s+(<?\s*\d+\.?\d*%)/i && $1 == 10);
	print OUT "Percentage above 20=$2\n" if (/coverage\s+=\s+(\d+).*?cum_frac\s+=\s+(<?\s*\d+\.?\d*%)/i && $1 == 20);
	print OUT "Percentage above 30=$2\n" if (/coverage\s+=\s+(\d+).*?cum_frac\s+=\s+(<?\s*\d+\.?\d*%)/i && $1 == 30);
    }
    close IN;
    close OUT;
    warn "Statistics written to $cap_out and $cap_out_detail\n";
    return $cap_out_detail;
}

#generate Venn Diagram
sub venn {
    warn "NOTICE: Do not support more than 5 files right now\n" and return undef unless (@_<=5);
    warn "NOTICE: No need to plot for single file\n" and return undef if (@_==1);

    my $exe="Rscript";
    #first check if Venn.diagram available
    my $rlibpath=File::Spec->catdir($install_dir,"rlib");
    #check installed packages in seqmule rlib and user's rlib
    my $installed_packages=`$exe --vanilla -e 'installed.packages(lib.loc=c("$rlibpath",.libPaths()))'`;
    unless ( $installed_packages=~/venndiagram/i)
    {
	warn "NOTICE: VennDiagram not installed, now try to install it.\n";
	&SeqMule::Utils::install_R_package($exe,"$install_dir/lib/VennDiagram_1.6.5.tar.gz",$rlibpath)
	    or die "Cannot install VennDiagram: $!\nWARNING:Please do it manually\n";
	$installed_packages=`$exe --vanilla -e 'installed.packages(lib.loc=c("$rlibpath",.libPaths()))'`;
    }

    #generate index
    die "ERROR: No VennDiagram package in R, please install it manually and try again.\n" unless $installed_packages=~/venndiagram/i;
    my $ref_avinput_name = shift;
    my @avinput_name = @$ref_avinput_name;
    my @avinput_pool=@_;
    my @snp_index_matrix;
    my @non_snp_index_matrix;
    my $snp_index_pool;
    my $non_snp_index_pool;

    #remove empty file
    for (@avinput_pool) {
	$_=undef unless (-s $_ >0);
    }
    @avinput_pool=grep {defined $_} @avinput_pool;
    warn "WARNING: failed to plot Venn diagram, number of nonempty files is more than 5 or smaller than 2.\n" and return unless @avinput_pool<=5 && @avinput_pool>=2;

    #generate index matrix
    for my $count(0..$#avinput_pool) {
	#*_index_matrix is array of array
	#first layer is array of file index
	#2nd layer is array of file name plus variants
	my $input = $avinput_pool[$count];
	my %snp_appear; #force uniqueness

	open IN,"<",$input or die "Cannot open $input:$!\n";
	$snp_index_matrix[$count]=[];
	$non_snp_index_matrix[$count]=[];
	my $illegal_input_count = 0;
	while (<IN>) {
	    #chr	start	end	ref	obs	...
	    #1		2	3	4	5
	    unless(/^([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)\t?.*$/) {
		$illegal_input_count++;
		next;
	    }

	    if ($2 == $3 and length($4) == 1 and length($5) == 1 ) {#start == end means this is a SNP 
		my $key=[$1,$2,$3,$4,$5];
		push @{$snp_index_matrix[$count]},$key and $snp_appear{$key}=1 unless $snp_appear{$key};
	    } else {
		#for indels, MVNs
		#use intervalization of 20bp (10bp in each direction)
		#as long as there's an overlap of interval
		#the two indels are considered as the same
		#non_snp_index_matrix will intervalized later
		#ref and obs field will not be useful if we use intervalization
		push @{$non_snp_index_matrix[$count]},[$1,$2-$INDEL_EXTENSION,$3+$INDEL_EXTENSION];
	    }
	}
	close IN;
	warn "WARNING: $input has $illegal_input_count illegal lines, expect >= 5 tab delimited fields\n" if $illegal_input_count > 0;
    }

    @non_snp_index_matrix = &gen_index_for_interval(\@non_snp_index_matrix);
    for my $count(0..$#avinput_name) {
	#add file name to head of array
	my $input = $avinput_name[$count];
	my ($name_prefix) = $input=~/^(.*)(\.avinput|\.tmp|\.vcf|\.consensus)$/i;

	unshift @{$snp_index_matrix[$count]},[$name_prefix];
	unshift @{$non_snp_index_matrix[$count]},[$name_prefix];
    }

    $snp_index_pool=File::Spec->catfile($tmpdir,$$.rand($$)."_snp_index_pool.tmp");
    $non_snp_index_pool=File::Spec->catfile($tmpdir,$$.rand($$)."_non_snp_index_pool.tmp");
    push @gunlink,$snp_index_pool;
    push @gunlink,$non_snp_index_pool;

    &write_index_pool($snp_index_pool,@snp_index_matrix);
    &write_index_pool($non_snp_index_pool,@non_snp_index_matrix);

    #make plot for SNP and non-SNP
    &genPlot("SNV",$snp_index_pool,scalar @avinput_pool);
    &genPlot("NON-SNV",$non_snp_index_pool,scalar @avinput_pool);
}
sub gen_index_for_interval {
    #be careful here
    #we are dealing with references
    #so any change to the content may have unexpected side effects
    my $ref = shift;
    #group all indels on the same chromosome
    #this is not memory-efficient, however, there are
    #only 344K indels on average for each genome
    #not too much memory even if we have 10 or 20 whole genomes here
    my %per_chr_interval;
    my @new; #the original index_matrix with updated index

    #put indels on the same chromosome together
    for my $file_idx(0..$#{$ref})
    {
	my $i = $ref->[$file_idx];
	for my $j(@$i)
	{
	    my $current_chr = $j->[0];
	    unless (defined $per_chr_interval{$current_chr})
	    {
		#assume chromosome name is unique
		#well, I haven't really seen a genome with duplicate
		#chromosome names inside it.
		$per_chr_interval{$current_chr} = [];
	    }
	    push @{$per_chr_interval{$current_chr}},[$j->[1],$j->[2],$file_idx];
	}
	#initialize @new
	$new[$file_idx] = [];
    }

    #sort intervals on the same chromosome
    for my $i(keys %per_chr_interval)
    {
	@{$per_chr_interval{$i}} = sort {
	$a->[0] <=> $b->[0] 
	    or $a->[1] <=> $b->[1] } @{$per_chr_interval{$i}};
    }
    #combine neighbour intervals
    for my $i(keys %per_chr_interval)
    {
	my $prev_pos = [0,0,0];
	my $prev_file_idx;

	for my $j(@{$per_chr_interval{$i}})
	{
	    #j is ref to array of size 3, the last element is filename
	    #prev_pos is ref to array of size 3
	    if ($j->[0] <= $prev_pos->[2] && $j->[1] >= $prev_pos->[1])
	    {
		#we encouter an overlapping interval
		#extend current interval
		if ($prev_pos->[1] > $j->[0])
		{ #for start, store whichever smaller
		    $prev_pos->[1] = $j->[0];
		}
		if ($prev_pos->[2] < $j->[1])
		{ #for end, store whichever bigger
		    $prev_pos->[2] = $j->[1];
		}
		if($prev_file_idx != $j->[2])
		{
		    #do I have to push every time???
		    #duplicate push into same file
		    #does not help
		    push @{$new[$j->[2]]},$prev_pos;
		    $prev_file_idx = $j->[2];
		}
	    } else
	    {
		#we encounter a non-overlapping interval
		$prev_pos = [$i,$j->[0],$j->[1]];
		#because here we got a new interval
		#we always push it
		push @{$new[$j->[2]]},$prev_pos;
		$prev_file_idx = $j->[2];
	    }
	}
    }
    #@new will consist of elements that
    #are reference to an array of references
    #for each interval (chr,start,end)
    #IDs for super-intervals will be chr+start+end
    #and there shouldn't be duplicates
    return @new;
}
sub write_index_pool {
    my $max=0;
    my $outfile = shift;
    my @index_matrix = @_;

    for my $i(0..$#index_matrix) {
	$max = @{$index_matrix[$i]} if @{$index_matrix[$i]} > $max;
    }

    open OUT,">",$outfile or die "ERROR: Cannot create $outfile for Venn Diagram: $!\n";
    for my $i(0..($max-1))
    {
	my @line;
	for my $j(0..$#index_matrix)
	{
	    if(defined $index_matrix[$j][$i] and @{$index_matrix[$j][$i]}>0) {
		push @line,(join "+",(grep {defined} @{$index_matrix[$j][$i]}));
	    } else
	    {
		push @line,"NA";
	    }
	}
	print OUT join("\t",@line),"\n";
    }
    close OUT;
}
sub genPlot {
    my $category = shift; #SNP or NON-SNP
    die "ERROR: category missing" unless defined $category;
    my $variant_index_pool=shift;
    my $count=shift;

    return unless $variant_index_pool && $count;
    #generate plot

    warn "NOTICE: Generating Venn diagram...\n"; 
    my $local_prefix=&getPrefix(split /,/,$venn);
    my $tiff="${local_prefix}_${category}_venn.tiff";
    my $jpg="${local_prefix}_${category}_venn.jpg";
    my $rfile="${local_prefix}_${category}_venn.R";
    my $exe="Rscript";
    my $rlibpath=File::Spec->catdir($install_dir,"rlib");
    my $rscript="#!$exe\n"; #exe path
    $rscript.=
    "x=read.delim(\"$variant_index_pool\",na.strings=\"NA\")\n".
    "y=list()\n".
    "title='Overlapping of $category variants'\n";
    #convert dataframe to list such that na=remove works
    for my $no(1..$count) {
	$rscript.=
	"y[[$no]]=x[[$no]]\nnames(y)[$no]=$no\n".
	"tmp=paste($no,names(x)[$no],sep=':')\n".
	"title=paste(title,tmp,sep=\"\\n\")\n"; #prevent category name overlapping with images
    }
    $rscript.="require(
    'VennDiagram',lib.loc=c('$rlibpath',.libPaths())
    )\n";

    #handle the scenario where some columns are empty
    $rscript.="
    for (i in y)
    {
    	if(length(i) == 0)
	{
		quit(save=\"no\",status=0)
	}
    }\n";

    #high resolution tiff output
    if ($count==5) {
	$rscript.="
	venn.diagram(y,fill=rainbow(length(y)),filename='$tiff',na=\"remove\",cex=0.65,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=-0.1,ext.length=0.9)
	";
    } elsif ($count==4) {
	$rscript.="
	venn.diagram(y,fill=rainbow(length(y)),filename='$tiff',na=\"remove\",cex=0.8,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=-0.1,ext.length=0.9)
	";
    } else {
	$rscript.="
	venn.diagram(y,fill=rainbow(length(y)),filename='$tiff',na=\"remove\",cex=1,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=0,ext.length=0.9)
	";
    }
#jpeg output for html report
    if ($count==5) {
	$rscript.="
	obj=venn.diagram(y,fill=rainbow(length(y)),filename=NULL,na=\"remove\",cex=0.65,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=-0.1,ext.length=0.9)
	jpeg('$jpg',width=5,height=5,units='in',res=500)
	grid.draw(obj)
	garbage <- dev.off()
	";
    } elsif ($count==4) {
	$rscript.="
	obj=venn.diagram(y,fill=rainbow(length(y)),filename=NULL,na=\"remove\",cex=0.8,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=-0.1,ext.length=0.9)
	jpeg('$jpg',width=5,height=5,units='in',res=500)
	grid.draw(obj)
	garbage <- dev.off()
	";
    } else {
	$rscript.="
	obj=venn.diagram(y,fill=rainbow(length(y)),filename=NULL,na=\"remove\",cex=1,main=title,main.cex=0.7,main.pos=c(0.5,1.2),main.just=c(0,1),ext.dist=0,ext.length=0.9)
	jpeg('$jpg',width=5,height=5,units='in',res=500)
	grid.draw(obj)
	garbage <- dev.off()
	";
    }

    &SeqMule::Utils::write2outfile($rscript,$rfile);
    chmod 0755,$rfile;
    die "ERROR: Execution failed, please run $rfile manually\n" if system("$exe --vanilla $rfile 1>&2");
    push @gunlink,$rfile;
    warn "NOTICE: Venn Digram plotted to $tiff and $jpg\n";
}

#convert files to annovar input format for easy handling
sub conv2anno {
    my @files=@_;
    my @return_files;
    my $exe_conver=&getExe("convert2annovar.pl");
    for (@files) {
	if (/^(.*)\.vcf(\.gz)?$/i)
	{
	    my $local_prefix=$1;
	    my $newout=File::Spec->catfile($tmpdir,(basename $local_prefix).(defined $sample?".$sample.":".").rand($$).".avinputready.tmp");
	    my $vcf_to_proc=$_;

	    unless($nofilter)
	    {
		#extract variants with PASS or . in FILTER field before conversion
		warn "NOTICE: Converting input file to ANNOVAR format, variants that failed to pass filtering will be ignored.\n";
		$vcf_to_proc = &rm_filtered_var_from_vcf($vcf_to_proc);
	    }

	    if (defined $sample)
	    {
		my $tmp_prefix=File::Spec->catfile($tmpdir,"$$".rand($$)."_annovar_raw"); #each sample will be saved at $tmp_prefix.<sample>.avinput
		!system("$^X $exe_conver -includeinfo -format vcf4 -allsample -outfile $tmp_prefix $vcf_to_proc")
		    and !system("mv $tmp_prefix.$sample.avinput $newout") or die "ERROR:$!\n";
	    } else
	    { 
		!system("$^X $exe_conver -includeinfo -format vcf4 $vcf_to_proc > $newout") or die "Failed to convert VCF to AVINPUT when no sample is given: $!\n";
	    }
	    push @gunlink,$newout;
	    push @return_files,$newout;
	} elsif (/^(.*)\.consensus$/) 
	{
	    my $tmp_soapsnp_avinput = File::Spec->catfile($tmpdir,$1.rand($$).".avinputready.tmp");
	    !system("$^X $exe_conver -includeinfo -format soap $_ > $tmp_soapsnp_avinput") or die "Failed to convert $_ from SOAPsnp format to AVINPUT format: $!\n";
	    push @gunlink,$tmp_soapsnp_avinput;
	    push @return_files,$tmp_soapsnp_avinput;
	} elsif (/\.avinput$/i) 
	{
	    push @return_files,$_;
	}else 
	{
	    warn "CAUTION: Unable to recognize $_, it will be ignored, only *.vcf, *.vcf.gz,*.consensus (by SOAPsnp) and *.avinput (by ANNOVAR) files are supported\n";
	}
    }
    return @return_files;
}

#extract consensus calls from candidate files	
sub var_consensus 
{
    my @to_be_extract=@_;
    my $first_file;
    my $output;
    my %count;
    my $consensus_var_count=0;
    my $local_prefix=&getPrefix(@to_be_extract);
    my $outfile="${local_prefix}_consensus.avinput";

    warn "NOTICE: Extracting consensus variants from @to_be_extract..\n";
    push @gunlink, (grep {/\.tmp$/i } @to_be_extract);

    no strict "vars"; #suppress undef warnings
    for my $item(@to_be_extract) 
    {
	open IN,"<", $item or die "ERROR: Cannot open $item: $!\n";
	while(<IN>) 
	{
	    warn "Invalid: $_\n" and next unless /^([^\t]+\t[^\t]+\t[^\t]+\t[^\t]+\t[^\t]+)\t.*$/;
	    $count{$1}++;
	}
	close IN;
    }
    use strict "vars";
    #6th and beyond columns come from the first file specified
    $first_file=$to_be_extract[0] or die "No input file\n";

    open IN,"<", $first_file or die "ERROR: Cannot open $first_file: $!\n";
    while(<IN>)
    {
	next unless /^([^\t]+\t[^\t]+\t[^\t]+\t[^\t]+\t[^\t]+)\t.*$/;
	$output.=$_ and $consensus_var_count++ if $count{$1}==@to_be_extract;
    }
    close IN;

    &SeqMule::Utils::write2outfile($output,$outfile);
    warn "NOTICE: $consensus_var_count variants written to $outfile ...\n";
}

#extract union calls from candidate files	
sub var_union 
{
    my @to_be_extract=@_;
    my $local_prefix=&getPrefix(@to_be_extract);
    my $outfile="${local_prefix}_union.avinput";
    my %union_lines;
    my $output;

    warn "NOTICE: Extracting union variants from @to_be_extract...\n";
    push @gunlink, (grep {/\.tmp$/i} @to_be_extract);

    no strict "vars";
    for my $item(@to_be_extract)
    {
	open IN,"<", $item or die "ERROR: Cannot open $item: $!\n";
	while(<IN>)
	{
	    #6th and beyond columns come from the last file with the variant
	    warn "Invalid: $_\n" and next unless /^([^\t]+\t[^\t]+\t[^\t]+\t[^\t]+\t[^\t]+)\t.*$/;
	    #chr include GL000192.1, ref and alt include . and - and +
	    $union_lines{$1}=$_; 
	}
	close IN;
    }
    use strict "vars";

    #output
    $output.= $union_lines{$_} for (keys %union_lines);
    &SeqMule::Utils::write2outfile($output,$outfile);
    warn "NOTICE: ",scalar (keys %union_lines)," variants written to $outfile.\n";
}

sub getPrefix
{
    my @files=@_;
    @files=map { abs_path $_ } @files;
    if ($prefix)
    {
	return $prefix;
    } else
    {
	die "ERROR: Empty list for getPrefix()" unless @_;
	return join("-",map { my $basename=basename $_; return $1 if defined && $basename=~/(.*)\.[^\.]*$/ or $basename=~/(.*)/ } @files); 
    }
}

sub getExe
{
    for my $exename(@_)
    {
	if ($loc{$exename})
	{
	    return $loc{$exename};
	} else
	{
	    if(my $exepath=&SeqMule::Utils::search($install_dir,$exename))
	    {
		$loc{$exename}=$exepath;
		return $exepath;
	    }
	}
    }
    die "ERROR: Failed to find @_\n";
}
sub loadPM
{
    eval {
	require VcfStats;
	require Vcf;
    };

    if ($@)
    { #no module found
	my $vcftools=shift;
	my $dir;
	$vcftools=abs_path($vcftools);
	$dir=dirname $vcftools;
	$dir=File::Spec->catdir($dir,"../perl");

	if (-f File::Spec->catfile($dir,"Vcf.pm") && -f File::Spec->catfile($dir,"VcfStats.pm"))
	{
	    $ENV{PERL5LIB}=($ENV{PERL5LIB}? $ENV{PERL5LIB}:'').":$dir";
	} else
	{
	    die "Failed to find Vcf.pm and VcfStats.pm for VCFtools\n";
	}
    } else
    {
	return 1;
    }
}
sub rm_filtered_var_from_vcf
{
    my $vcf_to_proc = shift;
    my $vcf_no_filtered_record=File::Spec->catfile($tmpdir,"$$".rand($$)."_nofiltered.vcf");
    !system("$^X -ne 'print if /^#|^[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t[^\\t]+\\t(PASS|\\.)\\t/' $vcf_to_proc > $vcf_no_filtered_record") or die "ERROR: Failed to extract variants that passed filtering or have no filter.\n";
    warn "NOTICE: ",
    (&SeqMule::Utils::countline($vcf_to_proc)-&SeqMule::Utils::countline($vcf_no_filtered_record)),
    " records removed because of being filtered.\n";
    push @gunlink,$vcf_no_filtered_record;
    return $vcf_no_filtered_record;
}
sub normalize_vcf
{
    #temporary output file names will be returned
    #be careful if you use getPrefix later on!!!
    my $vt = &getExe(&SeqMule::Utils::getProgramExe('vt'));
    my @return;
    warn "NOTICE: normalzing VCF with Vt...\n";
    for my $local_vcf(@_)
    {
	my $local_normal_vcf = File::Spec->catfile($tmpdir,"$$".rand($$)."_normalized.vcf");
	!system("$vt normalize -r $ref $local_vcf ".($verbose? "":"2>/dev/null")." | $vt mergedups - -o $local_normal_vcf ".($verbose? "":"2>/dev/null")) or die "ERROR: failed to normalize $local_vcf using vt ($!)\n";
	push @return,$local_normal_vcf;
	push @gunlink,$local_normal_vcf;
    }
    warn "NOTICE: done normalzing.\n";
    return @return;
}


__END__

=head1 NAME

SeqMule an automatic pipeline for next-generation sequencing data analysis

=head1 SYNOPSIS

seqmule stats <options>

For details, please use 'seqmule stats -h':

Options:

	--prefix,-p <STRING>      output prefix. Mandatory for multiple input files.
	--bam <BAM>               a sorted BAM file (used with --capture, --aln)
	--capture [BED]           a BED file for capture regions (or any other regions of interest). Effective for --bam and --vcf.
	--vcf <VCF>               output variant stats for a VCF file. If a BED file is supplied, extract variants based on the BED file.
	--aln                     output alignment stats for a BAM file
	--consensus,-c <LIST>     comma separated list of files for extracting consensus calls. 
				  VCF4 and SOAPsnp *.consensus format or ANNOVAR *.avinput required.
	--union,-u <LIST>         comma separated list of files for pooling variants (same format as above).
	--venn <LIST>             comma separated list of files for Venn diagram plotting (same format as above).
	--c-vcf <LIST>		  comma separated list of SORTED VCF files for extracting consensus calls. *.vcf or *.vcf.gz suffix required
	--u-vcf <LIST>		  comma separated list of SORTED VCF files for extracting union calls. *.vcf or *.vcf.gz suffix required
	--ref <FASTA>		  reference file in FASTA format. Effective for --c-vcf and --u-vcf.
	-s,--sample <STRING>	  sample name for VCF file, used for -vcf, -u, -venn, -c options.
	--plink			  convert VCF to PLINK format (PED,MAP). Only works with --vcf option.
	--mendel-stat		  generate Mendelian error statistics
	--paternal <STRING>	  sample ID for paternal ID (case-sensitive). Rest are either maternal or offspring. Only one family allowed.
	--maternal <STRING>	  sample ID for maternal ID (case-sensitive). Rest are either paternal or offspring. Only one family allowed.
	-N <INT>		  extract variants appearing in at least N input files. Currently only effective for --c-vcf option.
	--jmem <STRING>		  max java memory. Only effective for --c-vcf and --u-vcf. Default: 1750m
	--jexe <STRING>		  Java executable path. Default: java
	-t <INT>		  number of threads. Only effective for --aln, --c-vcf and --u-vcf. Default: 1
	--tmpdir <DIR>		  use DIR for storing large temporary files. Default: $TMPDIR(in your ENV variables) or /tmp
	--nofilter	          If specified, consider all variants, otherwise, only unfiltered variants.
	-h,--help                 help
	--noclean                 do not clean temporary files
	-v,--verbose		  verbose


=head1 EXAMPLES

	#draw Venn Diagram to examine overlapping between different VCF files
	seqmule stats -p gatk-soap-varscan -venn gatk.vcf,soap.avinput,varscan.vcf

	#extract union of all variants, ouput in ANNOVAR format
	seqmule stats -p gatk-soap-varscan -u gatk.vcf,soap.avinput,varscan.vcf

	#extract consensus of all variants, output in ANNOVAR format
	seqmule stats -p gatk_soap_varscan -c gatk.vcf,soap.avinput,varscan.vcf

	#extract consensus of all variants, output in VCF format
	seqmule stats -p gatk_soap_varscan -c-vcf gatk.vcf,soapsnp.vcf,varscan.vcf -ref hg19.fa

	#extract union of all variants, output in VCF format
	seqmule stats -p gatk_soap_varscan -u-vcf  gatk.vcf,soapsnp.vcf,varscan.vcf -ref hg19.fa

	#generate coverage statistics for specified region (region.bed)
	seqmule stats -p sample -capture region.bed --bam sample.bam

	#generate alignment statistics
	seqmule stats -bam sample.bam -aln

	#generate variant statistics
	seqmule stats -vcf sample.vcf

	#extract variants in specified region generate variant statistics
	seqmule stats -vcf sample.vcf -capture region.bed

	#generate Mendelian error statistics
	#NOTE, sample.vcf contains 3 samples!
	seqmule stats -vcf sample.vcf --plink --mendel-stat --paternal father --maternal mother

=head1 OPTIONS

=over 8

=item B<--capture>

SeqMule automatizes analysis of next-generation sequencing data by simplifying program installation, downloading of various databases, generation of analysis script, and customization of your pipeline.

=cut
