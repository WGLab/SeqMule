#!/usr/bin/env perl

#Copyright (C) <2012>  <Yunfei Guo>

##This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

##This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

##You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.


use warnings;
use strict;
#use diagnostics;
use FindBin qw/$RealBin/;
use File::Spec;
use lib File::Spec->catdir($RealBin,"..","..","lib");
use Pod::Usage qw/pod2usage/;
use Getopt::Long qw/GetOptions/;
use File::Copy qw/copy move/;
use File::Basename qw/basename dirname/;
use SeqMule::Utils;
use SeqMule::Parallel;
use SeqMule::SeqUtils;

#CONSTANTS
my $debug = 0;
my $PHRED_SCORE_CHECK_LINECOUNT = 1000;
my $HG18REF="human_b36_both.fasta";
my $HG19REF="human_g1k_v37.fasta";
my $GATKLITE_HARD_FILTER_BAM_SIZE=1_000_000_000; #in bytes, BAM files smaller than it will be subject to SNP hard filtering instead of VQSR
my $GATKLITE_INDEL_HARD_FILTER_BAM_SIZE=15_000_000_000; #in bytes, BAM files smaller than it will be subject to indel hard filtering instead of VQSR
my $GATK_HARD_FILTER_BAM_SIZE=1_000_000_000; #in bytes, BAM files smaller than it will be subject to SNP hard filtering instead of VQSR
my $GATK_INDEL_HARD_FILTER_BAM_SIZE=15_000_000_000; #in bytes, BAM files smaller than it will be subject to indel hard filtering instead of VQSR
my $RMDUP_MIN_LEN=10_000_000; #remove minimum 
my $SAMTOOLS_SORT_MEM_EXOME = '2G';
my $SAMTOOLS_SORT_MEM_GENOME = '2G'; #2G has been tested to work with wgs
my $TMPDIR;
my %VARIANT_QUAL_PRIORITY_LIST = (
    gatk_hc => 1,
    gatk_ug =>2,
    gatklite => 3,
    freebayes => 4,
    samtools =>5,
    varscan =>6,
    soapsnp=>7);

#cmd opt
my (
    $prefix,
    $normal_fq1,$normal_fq2,$normal_bam,$tumor_fq1,$tumor_fq2,$tumor_bam,
    $merge,$mergingrule,$multi_sample_calling,$minN,
    $buildver, $pl, $rg, $lb, $phred, $wes, $wgs, $force_one_rg,$union_rg,
    $threads, $sge, $nodeCapacity, $quick, $jexe, $java_mem, $tmpdir, $gatk_nt, $advanced,$norun,$nostat,$noremove,$force_rm_dup,
    $no_resolve_conflict,$no_check_chr, $no_check_aligner_index, $overwrite,
    $capture,$ref, $index_prefix, $bowtie_index_prefix, $bowtie2_index_prefix, 
    $soap_index_prefix, $hapmap, $dbsnp,  $dbsnpver,  $kg, $indel,
    $verbose, $help, 
);

#GLOBAL VARIABLES
my $install_dir=File::Spec->catdir($RealBin,"..","..");
my %loc; #record all found exes, files such that no need to search again
my @prefix_list;
my $analysis_prefix; #used for report folder, script name etc
my @merging_rule_list;
my $somatic_toggle = 0;
my $total_threads; #this is the original value specified by '--threads' option

#readgroup information
my @readgroup;
my @library;
my @platform;

#names of callers
#lowercase, variant callers, including gatklite, gatk_ug, gatk_hc,samtools,snver,freebayes,varscan, soapsnp
#intermediate files
my @obj_list;
my @small_bed;

my $script_file;
my $log;
my @commands;
#regular mode: ([1,"samtools"],[12,"bwa"])
#SGE mode (NOT IMPLEMENTED): ([1,"2g","samtools"],[12,"2g","bwa"])
my $date=`date +%m%d%Y`; chomp $date;

#files to be cleaned
my @removable; #unimportant intermediate files, remove at user's choice
my @script_unlink_list; #list consiting of temporarily generated file, should be removed at the end of generated script

#------------------------------------------------------------------------------------------------


#default values will be set at parsing advanced_config
@ARGV or pod2usage ({-exitval=>2,-verbose=>1});
GetOptions(
    #input and output
    'prefix|p=s'	=>	\$prefix,
    'a=s'	        =>	\$normal_fq1,
    'b=s'	        =>	\$normal_fq2,
    'bam=s'		=>	\$normal_bam,
    'a2=s'	        =>	\$tumor_fq1,
    'b2=s'	        =>	\$tumor_fq2,
    'bam2=s'		=>	\$tumor_bam,
    'merge|m'		=>	\$merge,
    'mergingrule=s'	=>	\$mergingrule,
    'ms'		=>	\$multi_sample_calling,
    'N=i'		=>	\$minN,
    #analysis param
    'build=s'	        =>	\$buildver,
    'platform|pl=s'	=> 	\$pl,
    'readgroup|rg=s'    =>	\$rg,
    'forceOneRG'	=>	\$force_one_rg,
    'unionRG'		=>	\$union_rg,
    'library|lb=s'	=>	\$lb,
    'phred=i'	        =>	\$phred,
    'wes|e'		=>	\$wes,
    'wgs|g'		=>	\$wgs,
    #runtime parameters
    'threads|t=i'	=>	\$threads,
    'sge=s'		=>	\$sge,
    'nodeCapacity|nc=i' =>	\$nodeCapacity,
    'quick|q'		=>	\$quick,
    'jmem=s'		=>	\$java_mem,
    'jexe=s'		=>	\$jexe,
    'tmpdir=s'		=>	\$tmpdir,
    'gatknt=i'		=>	\$gatk_nt,
    'advanced:s'	=>	\$advanced,
    'norun|nr'	        =>	\$norun,
    'nostat|ns'	        =>	\$nostat,
    'norm'		=>	\$noremove,
    'forceRmDup'	=>	\$force_rm_dup,
    'overWrite|ow'	=>	\$overwrite,
    #associated db
    'capture=s'		=>	\$capture,
    'no-resolve-conflict'=>	\$no_resolve_conflict,
    'no-check-chr'	=>	\$no_check_chr,
    'no-check-idx'	=>	\$no_check_aligner_index,
    'ref=s'	        =>	\$ref,
    'index=s'	        =>	\$index_prefix,
    'bowtie=s'	        =>	\$bowtie_index_prefix,
    'bowtie2=s'	        =>	\$bowtie2_index_prefix,
    'soap=s'	        =>	\$soap_index_prefix,
    'hapmap=s'	        =>	\$hapmap,
    'dbsnp=s'	        =>	\$dbsnp,
    'dbsnpver|dv=i'	=>	\$dbsnpver,
    'kg=s'	        =>	\$kg,
    'indel=s'		=>	\$indel, #indel gold standard
    #other
    'verbose|v'	        =>	\$verbose,
    'help|h'	        =>	\$help,
) or pod2usage({-exitval => 2,-verbose=>1});
$help||@ARGV and pod2usage ({-verbose=>2});


&procGlobalConf(); #all configurations are stored in global vars
&prefixCheck() if $prefix;
&confOptCheck(); #check again after options are deteremined
&proc_input ({
	bam => $normal_bam,
	fq1 => $normal_fq1,
	fq2 => $normal_fq2,
	tumor	=>	0,
    });
if ($tumor_bam || $tumor_fq1 || $tumor_fq2){
    die "ERROR: cannot analyze tumor sample without normal sample.\nPlease specify -a,-b,-bam options\n" 
    unless($normal_bam || $normal_fq1 || $normal_fq2);
    &proc_input ({
	    bam => $tumor_bam,
	    fq1 => $tumor_fq1,
	    fq2 => $tumor_fq2,
	    tumor	=>	1,
	});
    $somatic_toggle = 1;
}
#report important parameters/settings
&reportParam();
#script generation and running and stats
&genScript();
#execution
warn "To execute it, execute 'seqmule run $script_file'\n" and exit 0 if $norun;
#don't add die for the following command, it will die itself upon failure
exec File::Spec->catfile($install_dir,"bin","seqmule"),"run",$script_file,($sge?("-sge",$sge):());

#-----------------------------------subroutines for handling options --------------------------------------------
#set or generate proper advanced configuration file
#read settings or set default
sub procGlobalConf {
    #if $advanced is defined but empty, copy advanced_config and exit
    #otherwise assign its argument to $advanced for downstream processing
    my $conf_file= $advanced || File::Spec->catfile($install_dir,"misc","advanced_config");
#generate a template configuration file for customization
    if (defined $advanced) {
	unless ($advanced) {
	    copy($conf_file,"advanced_config") or die "advanced_config copy failed: $!\n";
	    warn "'advanced_config' was copied to current directory.\n".
	    "To use it, 'seqmule pipeline -advanced advanced_config' along with other options\n";
	    warn "NOTICE: More predefined config files can be found inside ",File::Spec->catfile($install_dir,"misc","predefined_config"),"\n";
	    exit;
	}
    }
    $advanced=$conf_file;
    #parse global configurations, store them in global variables
    open CONF,"<", $advanced or die "Cannot open $advanced: $!\n";
    #reading advanced_config 
    warn "Reading configuration file...\n";
    my @conf_lines;
    while (<CONF>) {
	next if /^#|^\s+$/;
	chomp;
	next unless /^(go_.*=.*?)(\s|#|$)/i;
	push @conf_lines,$1;
    }
    close CONF;
    warn "Done\n";
    warn "NOTICE: Commandline options will override advanced configuration.\n";
    warn "NOTICE: Parsing global settings...\n";
    for (@conf_lines) {
	my ($key,$value)= /(go_\w+=)(.*?)(\s+|#|$)/;
	if ($key=~/_threads=/i) {
	    $threads= $threads || $value;
	} elsif ($key=~/_jmem=/)
	{ $java_mem=$java_mem || $value;
	} elsif ($key=~/_jexe=/)
	{ $jexe=$jexe || $value;
	}elsif ($key=~/_gatknt=/){
	    $gatk_nt=$gatk_nt || $value;
	}elsif ($key=~/_platform=/i) {
	    $pl=$pl || $value;
	    $pl=uc $pl;
	} elsif ($key=~/_phred=/i) {
	    $phred=$phred || $value;
	} elsif ($key=~/_rg=/i) {
	    $rg=$rg || $value;
	    $rg=uc $rg;
	} elsif ($key=~/_lb=/i) {
	    $lb=$lb || $value;
	    $lb=uc $lb;
	} elsif ($key=~/_buildver=/) {
	    $buildver=$buildver || $value;
	} elsif ($key=~/_dbsnpver=/i) {
	    $dbsnpver=$dbsnpver || $value;
	} elsif ($key=~/_dbsnp=/i) {
	    $dbsnp=$dbsnp || $value;
	} elsif ($key=~/_hapmap=/i) {
	    $hapmap=$hapmap || $value;
	} elsif ($key=~/_kg=/i) {
	    $kg=$kg || $value;
	} elsif ($key=~/_ref=/i) {
	    $ref=$ref || $value;
	} elsif ($key=~/_index=/) {
	    $index_prefix=$index_prefix || $value;
	} elsif ($key=~/_bowtie=/) {
	    $bowtie_index_prefix=$bowtie_index_prefix || $value;
	} elsif ($key=~/_bowtie2=/)
	{	$bowtie2_index_prefix=$bowtie2_index_prefix || $value    }
	elsif ($key=~/_soap=/)
	{ $soap_index_prefix=$soap_index_prefix || $value   }
	elsif ($key=~/_capture=/) { 
	    $capture=$capture || $value;
	} elsif ($key=~/_tmpdir=/) { 
	    $TMPDIR = $tmpdir || $value;
	} else {	warn "CAUTION:undefined global setting ignored: $key\n"    }
    }
    $bowtie_index_prefix=$bowtie_index_prefix || $index_prefix || "";
    $bowtie2_index_prefix=$bowtie2_index_prefix || $index_prefix || "";
    $soap_index_prefix=$soap_index_prefix || $index_prefix || "";
    warn "Done\n";
    #in case no values are given for some options
    #we need to assign default values
    &assignDefault();
}

sub input_opt_check {
    my $local_opt = shift;
    my $fq1 = $local_opt->{fq1};
    my $fq2 = $local_opt->{fq2};
    my $bam = $local_opt->{bam};
    #check if options are specified properly, print necessary warnings
    if ($fq1 || $fq2 || $bam) {
	die "ERROR: use -g for whole-genome data, -e for exome (or captured) sequencing data\n" unless ($wes || $wgs);
	#die "No prefix. Use -p option.\n" unless $prefix;
	if ($fq1 || $fq2) {
	    die "ERROR: FASTQ and BAM files cannot be used together (-a or -b cannot work with -bam).\n" if $bam;
	    die "ERROR: first reads must be supplied together with second reads\n" if ($fq2 && !$fq1);
	    die "ERROR: No prefix given while FASTQ is supplied\n" unless $prefix;
	} else {
	    die "ERROR: No prefix given while merging files\n" if ($merge && !$prefix);
	}
    } else {
	#no input
	die "ERROR: no input files while merge is enabled\n" if $merge;
	die "ERROR: No input while advanced_config is specified\n" if $advanced;
	die "No input, exit\n" unless (defined $advanced); #argument of -advanced is optional
    }
}
sub prefixCheck {
    #check prefix specification
    die "ERROR: No underscore/slash/back slash allowed in prefix, please consider using a hyphen instead\n" if $prefix=~/[\_\\\/]/;
    die "ERROR: No path allowed in prefix\n" if $prefix=~/[\\\/]/;
    @prefix_list=split /,/,$prefix;
    die "ERROR: Remove duplicate prefix: @prefix_list\n" unless @prefix_list == &SeqMule::Utils::uniq(@prefix_list);
    if ($multi_sample_calling) {
	@prefix_list >1 or die "At least two samples are required for multi-sample calling.\n";
    }
    &genAnalysisPrefix();
}

sub reportParam {
    warn "NOTICE: Analysis name: $analysis_prefix\n" if $analysis_prefix;
    warn "NOTICE: Somatic mutation calling mode\n" if $somatic_toggle;
    warn "NOTICE: All input is merged on a per-sample basis (after alignment for FASTQ).\n" if $merge;
    warn "NOTICE: Input is exome (or captured) sequencing data\n" if $wes;
    warn "NOTICE: Input is whole genome data\n" if $wgs; 
    warn "NOTICE: BED file used for caculating coverage statistics and extracting variants: ",(basename $capture),"\n" if $wes;
    warn "NOTICE: Readgroup : $rg\n";
    warn "NOTICE: Sequencing platform: $pl\n";
    warn "NOTICE: Library : $lb\n";
    warn "NOTICE: Phred scoring scheme : $phred\n" if $normal_fq1;
    warn "NOTICE: Reference genome build is $buildver\n";
    warn "NOTICE: dbsnp$dbsnpver will be used for variant calling and recalibration.\n";
    warn "NOTICE: Java memory usage is limited to $java_mem\n";
    warn "NOTICE: java executable path: $jexe\n" if $jexe;
    warn "NOTICE: Max number of processes: $threads\n";
    warn "NOTICE: Variants shared by at least $minN combinations of aligners and callers will be printed.\n" if $minN;
    warn "NOTICE: Variant calling will be run in parallel mode [EXPERIMENTAL].\n" if $quick;
    warn "NOTICE: Multi-sample variant calling ENABLED.\n" if $multi_sample_calling;
    warn "NOTICE: $TMPDIR will be used for storing temporary files\n";
}

sub writeLog {
    $log="$analysis_prefix.log";
    my @callers = SeqMule::SeqUtils->get_attr_enum('caller',@obj_list);
    my @aligners = &get_aligner;
    warn "NOTICE: log file will be overwritten: $log\n" if -f $log;
    open LOG,'>',$log or die "Failed to write to $log: $!\n";

    #logging
    print LOG scalar @prefix_list," sample(s) in this analysis: @prefix_list\n";
    print LOG "Somatic mutation calling mode\n" if $somatic_toggle;
    print LOG "All input is merged on a per-sample basis (after alignment if FASTQ).\n" if $merge;
    if (@prefix_list>1) {
	if ($multi_sample_calling) {
	    print LOG "Multi-sample variant calling ENABLED.\n";
	} else {
	    print LOG "Multi-sample variant calling DISABLED.\n";
	}
    }
    print LOG "Input is exome (or captured) sequencing data.\n" if $wes;
    print LOG "Input is whole genome sequencing data.\n" if $wgs;
    print LOG scalar @callers," variant caller(s) used: ",join(" ",&SeqMule::Utils::callers2names(@callers)),"\n" if @callers;
    print LOG scalar @aligners," aligner(s) used: @aligners\n" if @aligners;
    print LOG "Variants shared by at least $minN combinations of aligners and callers are printed.\n" if $minN;
    print LOG "File used for caculating coverage statistics and extracting variants: ",(basename $capture),"\n" if $wes;
    print LOG "Readgroup : $rg\n";
    print LOG "Library : $lb\n";
    print LOG "Sequencing platform: $pl\n";
    print LOG "Reference genome build is $buildver\n";
    print LOG "dbsnp$dbsnpver is used for variant calling and recalibration (in GATK VQSR).\n";
    print LOG "Java memory usage is limited to $java_mem\n";
    print LOG "java executable path: $jexe\n" if $jexe;
    print LOG "Max number of processes: $total_threads\n";
    print LOG "Variant calling are run in parallel mode [EXPERIMENTAL].\n" if $quick;
    print LOG "NOTICE: $TMPDIR will be used for storing temporary files\n";

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my $result_folder = &get_result_folder($sample);

	print LOG "###################################################\n";
	print LOG "FINAL OUTPUT for $sample:\n";
	print LOG "###################################################\n";
	print LOG "NOTICE: Both consensus results and individual results are listed.\n";
	print LOG "WARNING: consensus results may not be available because some variant callers or aligners may fail to generate output.\n";
	print LOG join "\n", map {$_->file()} 
	(grep {$_->caller eq 'consensus' && $_->filetype eq 'VCF' &&
	    $_->sample eq $sample } @obj_list);
	print LOG "\n";
	print LOG join "\n", map {$_->file()} 
	(grep {$_->caller ne 'consensus' && $_->filetype eq 'VCF' &&
	    $_->sample eq $sample } @obj_list);
	print LOG "\n";
    }
    close LOG;
    warn "NOTICE: log written to $log\n";
}

sub procFQ {
    my $local_opt = shift;
    my $tumor = $local_opt->{tumor};
    my @fq1_list = @{$local_opt->{fq1}};
    my @fq2_list = @{$local_opt->{fq2}};
    if ( grep { $_ !~ /\.(fq|fastq|fastq\.gz|fq\.gz)$/i } (@fq1_list,@fq2_list) ) {
	die "ERROR: All FASTQ files must have suffix .fq.gz .fastq.gz .fq or .fastq\n";
    }
    unless ($merge) {
	die "ERROR: number of prefixes must equal number of FASTQ files\n" 
	if (@fq1_list && $#prefix_list != $#fq1_list);
    }

    die "ERROR: number of FASTQ files for 1st and 2nd read pair must be equal!\n" 
    if (@fq1_list && @fq2_list && $#fq1_list != $#fq2_list);

    for my $i(0..$#prefix_list) {
	#create symlinks such that all corresponding output have consistent prefix
	#this step is critical for fastqc processing
	my $result_folder = &get_result_folder($prefix_list[$i]);
	#generate a symbolic link for each fastq file
	#place all fastq files belonging to the same sample under sample_result folder
	#we also need to check if the links already exist
	my @fq_idx_range = &SeqMule::Utils::gen_idx_range_by_mergingrule($i,@merging_rule_list);
	for my $j(@fq_idx_range)
	{
	    my @rank = (0,1);
	    my @paired_obj;
	    for my $k(@rank) #are we dealing with first or second fastq in a pair?
	    {
		my $file = ($k == 0? $fq1_list[$j] : $fq2_list[$j]);
		next unless $file;
		my $fq = SeqMule::SeqUtils->new( 	
		    'file'	=> $file,
		    'filetype'	=> 'FASTQ',
		    'sample'	=> $prefix_list[$i],
		    'rg'	=> $readgroup[$i],
		    'lb'	=> $library[$i],
		    'pl'    	=> $platform[$i],
		    'rank'	=> $k,
		    'istumor'	=> $tumor,
		);
		$fq->ancestor($fq);
		my $newfq = $fq->gen_symlink(
		    File::Spec->catfile(
			$result_folder,
			#here I used a trick for join
			#join will ignore an empty list ()
			#undef will still cause join to add another separator, though
			join(".",$fq->sample(),
			    ($merge? &SeqMule::Utils::get_rank_by_mergingrule($i,$j,@merging_rule_list) : ()),
			    $fq->rank(),
			    ($tumor? "tumor":()),
			    "fastq",
			    ($fq->file()=~/\.gz$/i ? "gz" : ()), 
			)
		    ),$overwrite);
		$newfq->rank($k);
		warn "fqlink: ".$newfq->file."rank".$newfq->rank()."\n" if $debug;
		$paired_obj[$newfq->rank()] = $newfq;
	    }
	    if(@paired_obj == 2) {
		$paired_obj[0]->sibling($paired_obj[1]);
		$paired_obj[1]->sibling($paired_obj[0]);
	    }
	    push @obj_list,@paired_obj;
	}
    }
#examine first 1000 reads, count bases in ASCII code 33-58 for phred33 and 80-104 for phred64
    check_obj(@obj_list) if $debug;
    $phred = &SeqMule::Utils::phred_score_check($PHRED_SCORE_CHECK_LINECOUNT,(map{$_->file() if $_->filetype() eq 'FASTQ'} @obj_list)) if ($phred==1);
}

sub procBAM {
    my $local_opt = shift;
    my $tumor = $local_opt->{tumor};
    my @bam_list = @{$local_opt->{bam}};
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
    if (grep { $_ !~ /\.bam$/ } @bam_list) {
	warn "@bam_list\n";
	die "ERROR: All BAM files must have suffix .bam\n";
    }
    $#bam_list==$#prefix_list 
	or die "ERROR: Prefixes for BAM files are mandatory.\nAnd they must equal to BAM files unless merging is used.\n";


    if ($merge) {
	for my $i(0..$#prefix_list) {
	    my $result_folder = &get_result_folder($prefix_list[$i]);
	    my $onebam = SeqMule::SeqUtils->new(
		'file'		=> File::Spec->catfile($result_folder,$prefix_list[$i].($tumor? "tumor":"").".merge.bam"),
		'filetype'	=> 'BAM',
		'sample'	=> $prefix_list[$i],
		'istumor'	=> $tumor,
	    );
	    #although aligner information is unavaiable, we still need it to figure out
	    #one_aligner_bam later
	    $onebam->aligner('NA');
	    my @bam_idx_range = &SeqMule::Utils::gen_idx_range_by_mergingrule($i,@merging_rule_list);
	    my @one_sample_input_bam;
	    for my $j(@bam_idx_range) {
		my $obj = SeqMule::SeqUtils->new( 	
		    'file'	=> $bam_list[$j],
		    'filetype'	=> 'BAM',
		    'sample'	=> $prefix_list[$i],
		    'istumor'	=> $tumor,
		);
		$obj->aligner('NA');
		#only one sample is allowed in each BAM, so we can safely 
		#assume only one sample here
		my $sample_in_bam = &SeqMule::Utils::getBAMSample($samtools,$bam_list[$j]);
		die "ERROR: didn't find sample name in $bam_list[$j]\n" unless defined $sample_in_bam;
		die "ERROR: prefix <<$prefix_list[$i]>> is not equal to sample <<$sample_in_bam>> found in $bam_list[$j]\n"
		unless $prefix_list[$i] eq $sample_in_bam;
		push @one_sample_input_bam,$obj;
	    }
	    $onebam->rg($readgroup[$i]) if ($force_one_rg);

	    #ancestor will be set by merge_bam
	    &merge_bam($onebam,@one_sample_input_bam);
	    #replace BAMs-to-be-merged with merged BAM
	    push @obj_list,$onebam;
	}
    } else {
	for my $i(0..$#prefix_list) {
	    my $result_folder = &get_result_folder($prefix_list[$i]);
	    my $original_bam = SeqMule::SeqUtils->new( 	
		'file'	=> $bam_list[$i],
		'filetype'	=> 'BAM',
		'sample'	=> $prefix_list[$i],
		'istumor'	=> $tumor,
	    );
	    $original_bam->aligner('NA');

	    my $sample_in_bam = &SeqMule::Utils::getBAMSample($samtools,$bam_list[$i]);
	    die "ERROR: didn't find sample name in $bam_list[$i]\n" unless defined $sample_in_bam;
	    die "ERROR: prefix $prefix_list[$i] is not equal to sample $sample_in_bam found in $bam_list[$i]\n"
	    unless $prefix_list[$i] eq $sample_in_bam;

	    $original_bam->ancestor($original_bam);
	    my $newbam = $original_bam->gen_symlink(
		File::Spec->catfile(
		    $result_folder,$original_bam->sample().
		    ($tumor? "tumor":"").
		    ".bam"
		),$overwrite);
	    push @obj_list,$newbam;
	}
	&checkBAMSample($samtools,@obj_list);
    }
    #check contig, try to resolve inconsistency
    if (not $no_check_chr) {
	warn "NOTICE: use --no-check-chr to skip chromosome name checking\n";
	for my $local_bam_obj(@obj_list) {
	    next unless $local_bam_obj->filetype() eq 'BAM';
	    #compare chromosome name in ref and BED, complain if they don't match
	    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	    my $local_bam = $local_bam_obj->file();
	    my $chr_compare=&SeqMule::Utils::compareChr({
		    samtools=>$samtools,
		    type1=>'fasta',
		    file1=>$local_ref,
		    type2=>'bam',
		    file2=>$local_bam, 
		});
	    if ($chr_compare==0) {
		die "ERROR: $local_bam contains chromosome names that are not in reference.\n" 
	    } elsif ($chr_compare==1) { 
		warn "NOTICE: contig names in BAM file and reference match with each other.\n";
	    } elsif ($chr_compare==2) {
		warn "WARNING: contig names in BAM file do NOT match reference.\n";
		if ($no_resolve_conflict) {
		    die "ERROR: SeqMule cannot continue unless contig names are matched between reference and BAM file.\n";
		} else {
		    #try remove or add 'chr'
		    #check @SQ tags, try to fix inconsistent tags
		    warn "NOTICE: SeqMule now tries to fix inconsistent contig names. A new copy of BAM file will created.\n";
		    my $newbam_obj = $local_bam_obj->clone();
		    my $newbam_file = $local_bam_obj->file();
		    $newbam_file =~ s/\.bam/.chrmod.bam/;
		    $newbam_obj->file($newbam_file);
		    $newbam_obj->parent($local_bam_obj);
		    $local_bam_obj->child($newbam_obj);

		    warn "WARNING: $newbam_file will be overwritten.\n" if -e $newbam_file or -l $newbam_file;
		    &SeqMule::Utils::addOrRmChrInBAM($samtools,$local_bam,$newbam_file);

		    $local_bam_obj=$newbam_obj;
		}
	    } else {
		die "ERROR: unrecognized return code for contig name comparison.\n";
	    }
	}
    }

    #sort all BAMs as we cannot assume they are aligned
    for my $local_bam_obj(@obj_list) {
	next unless $local_bam_obj->filetype() eq 'BAM';
	my $local_bam = $local_bam_obj->file();
	my ($local_prefix)= $local_bam=~/(.*)\.bam$/;
	die "ERROR: $local_bam must have *.bam as file name\n" unless defined $local_prefix;
	my $newbam_obj = $local_bam_obj->clone();
	my $newbam_file="$local_prefix.sort.bam";
	my $newbam_prefix="$local_prefix.sort";
	#we need to write dependency info before command is generated
	#as we need file dependency to resolve command dependency
	$newbam_obj->file($newbam_file);
	$newbam_obj->parent($local_bam_obj);
	$local_bam_obj->child($newbam_obj);

	push @commands, {
	    nCPU_requested=>$threads,
	    message	=>"Sort BAM input assuming it is not sorted",
	    command	=>["$samtools sort -m ".($wes? $SAMTOOLS_SORT_MEM_EXOME:$SAMTOOLS_SORT_MEM_GENOME)." -\@ $threads $local_bam $newbam_prefix"],
	    in		=>[$local_bam_obj],
	    out		=>[$newbam_obj],
	};
	$local_bam_obj = $newbam_obj; 
	push @removable,$newbam_obj;
    }
}

sub confOptCheck {
#check global options
    if ($buildver !~ /^(hg18|hg19)$/ ) {
	die "ERROR: Illegal build version $buildver, use hg18 or hg19\n";
    }  #standardize build version
    die "Only support ILLUMINA and IONTORRENT.\n" unless ($pl =~ /illumina|iontorrent/i);
    if ($normal_fq1) { 
	die "ERROR: Illegal Phred score scheme: use 1 (auto-detect), 33 or 64\n" 
	unless ($phred==1 or $phred==33 or $phred==64);
    }
    die "ERROR: use integers for threads option: $threads\n" unless $threads=~/^\d+$/;
    die "ERROR: use integers for GATK threads option: $gatk_nt\n" unless $gatk_nt=~/^\d+$/;
    die "ERROR: at least 2 threads required for QUICK mode" if $threads<2 && $quick;

    #$threads has been assigned a default value by now
    #record the original number of threads
    $total_threads = $threads;
    $threads = $nodeCapacity if $nodeCapacity and $threads>$nodeCapacity;
    #check capture file
    if ($capture && $capture=~/^default$/i) {
	#see if we should modify default capture file to match custom reference
	my $defaultCapture = "${buildver}_exonPlus5bp_UCSCrefGene.bed";
	warn "NOTICE: use default BED file $defaultCapture\n";
	$capture=File::Spec->catfile($install_dir,"misc",$defaultCapture); #make sure buildver is assigned a value
    }
    if ($capture) {
	$capture = &SeqMule::Utils::abs_path_failsafe($capture);
	die "ERROR: $capture must have .bed suffix.\n" unless $capture=~/\.bed$/;
	die "ERROR: $capture does NOT exist or is empty\n" if !-f $capture or -s $capture <=0;
	#compare chromosome name in ref and BED, complain if they don't match
	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $chr_compare=&SeqMule::Utils::compareChr({	type1=>'fasta', file1=>$local_ref, type2=>'bed', file2=>$capture, });
	if (not $no_check_chr) {
	    warn "NOTICE: use --no-check-chr to skip chromosome name checking\n";
	    if ($chr_compare==0)
	    {
		die "ERROR: $capture file contain chromosome names that are not in reference.\n" 
	    } elsif ($chr_compare==1)
	    { 
		warn "NOTICE: contig names in capture file and reference match with each other.\n";
	    } elsif ($chr_compare==2)
	    {
		warn "WARNING: contig names in capture file do NOT match reference.\n";
		if ($no_resolve_conflict)
		{
		    die "ERROR: SeqMule cannot continue unless contig names are matched between reference and BED file.\n";
		}else
		{
		    #try remove or add 'chr'
		    warn "NOTICE: SeqMule now tries to resolve inconsistent contig names.\n";
		    my $tmp=basename $capture; 
		    $tmp=~s/\.bed$/.chrmod.bed/;#fix the naming to avoid generating new file each run
		    warn "NOTICE: $tmp will be used to replace $capture.\n";
		    if (!$overwrite and -e $tmp) {
			my $tmp_chr_compare=&SeqMule::Utils::compareChr({type1=>'fasta', file1=>$local_ref, type2=>'bed', file2=>$tmp, });
			if ($tmp_chr_compare == 1) {
			    $capture=$tmp;
			} else {
			    die "ERROR: SeqMule tries to create $tmp for you, but target exists and its content differs from what SeqMule expects.\nPlease remove or rename it.\n";
			}
		    } else {
			$capture=&SeqMule::Utils::addOrRmChrInBED($capture,$tmp);
		    }
		}
	    } else {
		die "ERROR: unrecognized return code for contig name comparison.\n";
	    }
	}
    }
    if ($capture && &SeqMule::Utils::checkOverlapBED($capture)) {
	#remove overlapping regions in BED, generate a new BED if necessary
	warn "NOTICE: SeqMule now tries to resolve overlapping regions in BED file.\n";
	my $tmp = basename $capture; 
	$tmp =~ s/\.bed$/.nooverlap.bed/;#fix the naming to avoid generating new file each run
	warn "NOTICE: $tmp will be used to replace $capture.\n";
	if (!$overwrite && (-e $tmp || -l $tmp) && &SeqMule::Utils::checkOverlapBED($tmp)) {
	    die "ERROR: SeqMule tries to create $tmp for you, but target exists and it contains overlapping regions.\nPlease remove or rename it.\n";
	} else {
	    $capture=&SeqMule::Utils::rmOverlapBED($capture,$tmp);
	}
    }

    warn "NOTICE: Input BED file detected, only variants in corresponding regions will be generated.\n" if $capture;
    #get @RG info
    #
    if ($pl =~ /,/) {
	@platform=split /,/,$pl;
	die "ERROR: when over 1 platforms are specified, number of platforms must equal number of samples\n" unless @platform == @prefix_list;
    } else {
	@platform=map { $pl } @prefix_list;
    }

    if ($lb =~ /,/) {
	@library=split /,/,$lb;
	die "ERROR: when over 1 libraries are specified, number of libraries must equal number of samples\n"  unless @library == @prefix_list;
    } else {
	@library=map {$lb} @prefix_list;
    }

    #make sure every sample has a RG/PL/LB
    #in principle, we need to specify RG/PL/LB for every input file
    #for now, we just make sure every sample have its own tags
    if ($rg =~ /,/) {
	@readgroup=split /,/,$rg;
	die "ERROR: when over 1 readgroup IDs are specified, number of readgroup IDs must equal number of samples\n"   unless @readgroup == @prefix_list;
    } else {
	#when only one RG is specified
	#automatically generate a uniq RG for each sample
	@readgroup=map {"${rg}_$prefix_list[$_]"} (0..$#prefix_list);
	$rg=join ',',@readgroup;
    }
    die "ERROR: -rg is missing while -forceOneRG is used.\n" if ($force_one_rg && !$rg);
    die "ERROR: no multiple readgroups allowed while -forceOneRG is used.\n" if ($force_one_rg && $rg=~/,/);
    die "ERROR: -forceOneRG cannot be used without -merge option.\n" if ($force_one_rg && !$merge);
    die "ERROR: -capture should NOT be used with -wgs/-g option. If you already have VCF files and want to calculate coverage statistics or extract variants in certain regions, please use 'seqmule stats -capture <BED> -vcf <VCF>'.\n" if $capture && $wgs;
    die "ERROR: -g -e cannot be specified together\n" if ($wes && $wgs);
    die "ERROR: '-capture <BED>' must specified for exome/captured data. Alternatively, you can use '-capture default' to analyze with default exome region definition.\nAll steps except alignment are done solely for the specified region.\nSome popular BED files can be downloaded by 'seqmule download -bed'.\n" if ($wes && !$capture);
    warn "CAUTION: You used your own reference file or index file, there is no guarantee that it will work with all programs.\n" if ($ref || $index_prefix || $bowtie_index_prefix || $bowtie2_index_prefix || $soap_index_prefix);
    warn "CAUTION: You used your own variant database, there is no guarantee that it will work with all programs.\n" if ($dbsnp || $kg || $hapmap);
    warn "Entering verbose mode...\n" if $verbose;
    &checkForSplit() if $quick;
}
sub checkForSplit {
    #bam, ref, capture bed all have been examined and compared
    #warn user if region to be split is too small
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $bed=$capture || &SeqMule::Utils::fa2BED($local_ref);
    &SeqMule::Utils::splitRegion({bed=>$bed,threads=>$threads,rm=>1});
}
#option check
sub proc_input {
    my $local_opt = shift;
    my @fq1_list;
    my @fq2_list;
    my @bam_list;
    my $fq1 = $local_opt->{fq1};
    my $fq2 = $local_opt->{fq2};
    my $bam = $local_opt->{bam};
    my $tumor = $local_opt->{tumor};

    &input_opt_check({fq1=>$fq1,fq2=>$fq2,bam=>$bam});
    #parse FQ file names
    @fq1_list=split /,/,$fq1 if $fq1; @fq1_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @fq1_list;
    @fq2_list=split /,/,$fq2 if $fq2; @fq2_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @fq2_list;
    #parse BAM file names
    @bam_list=split /,/,$bam if $bam; 
    @bam_list= map { &SeqMule::Utils::abs_path_failsafe($_) } @bam_list;

    &checkMerge(@fq1_list + @bam_list); #check if merging rule is reasonable based on number of samples and files, this must be done even if merging is not enabled
    if ($multi_sample_calling && $tumor){
	die "ERROR: somatic calling and multi-sample calling cannot be done at the same time.\n" 
    }
    &procFQ({fq1=>\@fq1_list,fq2=>\@fq2_list,tumor=>$tumor,}) if $fq1;
    &procBAM({bam=>\@bam_list,tumor=>$tumor,}) if $bam;
}
sub checkMerge {
    my $file_count = shift;
    #set merging rule
    if ($mergingrule) {
	@merging_rule_list = split /,/,$mergingrule;
    } else { #by default, seqmule tries to assign the files evenly among samples
	die "ERROR: no prefix found\n" if @prefix_list == 0;
	@merging_rule_list = (int ($file_count/@prefix_list)) x @prefix_list;
    }
    if(&SeqMule::Utils::sum(@merging_rule_list) != $file_count) {
	die "ERROR: total number of files specified by merging rule is not equal to number of input files\n".
	"It is also possible that SeqMule fails to assign integer number of files to each sample equally.\n".
	"Parsed merging rule: @merging_rule_list\n".
	"Number of files: $file_count\n".
	"Number of samples: ".(scalar @prefix_list)."\n";
    }
    if(grep {$_ <= 0} @merging_rule_list) {
	die "ERROR: all numbers in merging rule should be larger than 0\n";
    }
}

sub genAnalysisPrefix
{
    my @tmp=@prefix_list;
    if(@tmp>4) {
	warn "NOTICE: when there are over four samples, the first 4 sample names are used as analysis name.\n";
	@tmp=@tmp[0,1,2,3];
    }
    $analysis_prefix=join('-',@tmp);
}

#######################SUBROUTINES FOR PIPELINE GENERATION#######################
#cmd_gen is very specific
sub parsePipeline {
    my @advanced_config_lines=&SeqMule::Utils::parsePipeline($advanced);
    $advanced="$analysis_prefix.config";
    warn "NOTICE: Analysis configuration log will be overwritten: $advanced\n" if -f $advanced or -l $advanced;
    open OUT,'>',$advanced or die "Failed to write to $advanced: $!\n";
    print OUT "#This file is ONLY for LOGGING purposes, so do NOT run SeqMule with it.\n";

    #walk through advanced_config to figure each step
    my $no=0;
    for (0..$#advanced_config_lines)
    {
	my ($program,$subprogram,$option_ref)=@{$advanced_config_lines[$_]};

	if ($program=~/^samtools$/i && $subprogram=~/rmdup/i && $capture && $wes)
	{
	    if (&SeqMule::Utils::bed2total($capture)<$RMDUP_MIN_LEN)
	    {
		warn "NOTICE: capture region smaller than $RMDUP_MIN_LEN, skip removal of duplicates (use --forceRmDup to enable it).\n"
		    and next unless $force_rm_dup or $option_ref->{forceRm};
	    }
	}

	$no++;
	warn "Generating: $no,$program,$subprogram\n" if $verbose;
	&cmd_gen($no,$program,$subprogram,$option_ref);

	print OUT "${no}P_${program}",($subprogram? "_$subprogram":""),"=1\n";
	while (my ($opt,$val)=each %$option_ref)
	{
	    print OUT "o_${program}_$opt=$val\n";
	}
    }

    close OUT;

    #complain about some particular configuration
    if ( $merge && grep {/soap/} (SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)) ) {
	die "ERROR: SOAPaligner alignments cannot be merged.\n";
    }
    if ($multi_sample_calling && grep { /soapsnp/} SeqMule::SeqUtils->get_attr_enum('caller',@obj_list)) {
	die "ERROR: SOAPsnp does not support multi-sample variant calling\n";
    }

    warn "NOTICE: Final configurations written to $advanced\n";
}
sub cmd_gen {

    my ($n,$program,$subprogram,$options_ref)=@_;
    warn "***Preparing $program\n\n" if $verbose;
    $program=lc $program;

    if ($program eq 'fastqc') {
	return &fastqc(@_);
    } 
    elsif ($program eq 'bwa') {
	return &bwa(@_);
    } elsif ($program eq 'bwamem') {
	return &bwa_mem(@_);
    } elsif ($program eq 'bowtie') {
	return &bowtie(@_);
    } elsif ($program eq 'bowtie2') {
	return &bowtie2(@_);
    } elsif ($program eq 'soap') {
	return &soap(@_);
    } elsif ($program eq 'snap') {
	return &snap(@_);
    } elsif ($program eq 'samtools') {
	return &samtools(@_);
    } elsif ($program eq 'varscan') {
	return &varscan(@_);
    } elsif ($program eq 'picard') {
	return &picard(@_);
    } elsif ($program eq 'gatklite') {
	return &gatk(@_);
    } elsif ($program eq 'gatk') {
	return &gatk_full(@_);
    } elsif ($program eq 'freebayes') {
	return &freebayes(@_);
    } elsif ($program eq 'snver') {
	return &snver(@_);
    } elsif ($program eq 'soapsnp') {
	return &soapsnp(@_);
    } else {die "ERROR: Unrecognized program: $program\n"}
}

#subroutines for each external program
sub fastqc {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my $fastqc = &getExe(&SeqMule::Utils::getProgramExe("fastqc"));
    warn "FastQC executable: $fastqc\n" if $verbose;
    my $extractSummary = File::Spec->catfile($install_dir,"bin","secondary","convertQCstat");
    for my $i(@obj_list) {
	next unless $i->filetype() eq 'FASTQ' or $i->filetype() eq 'BAM';
	my $fastqc_result_obj = $i->clone();
	$fastqc_result_obj->parent($i);
	$i->child($fastqc_result_obj);
	$fastqc_result_obj->filetype('STATS');
	$fastqc_result_obj->file('FastQC for '.$i->file);
	push @commands, {
	    #only 1 CPU is assigned for each file, actually fastqc works this way internally
	    nCPU_requested	=>	1,
	    message		=>	"QC assesment on input",
	    command		=>	["$fastqc --extract ".$i->file()],
	    in			=>	[$i],
	    out			=>	[$fastqc_result_obj],
	};
	push @obj_list,$fastqc_result_obj;
    }
    #extactSummary cannot be run until fastqc has processed all FQ files from same sample
    #because it writes to one single file for each sample
    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my $result_folder = &get_result_folder($sample);
	my $qcstat = File::Spec->catfile($result_folder,"${sample}_qc_stat.txt");
	my @same_sample_stat_obj = grep {$_->filetype eq 'STATS' && $_->sample eq $sample} @obj_list;
	my $qc_stat_obj = $same_sample_stat_obj[0]->clone();
	#use parent method to remove duplicate obj
	$qc_stat_obj->parent(map {$_->parent} @same_sample_stat_obj);
	my @same_sample_data_obj = $qc_stat_obj->parent;
	#set correct parent
	$qc_stat_obj->parent(@same_sample_stat_obj);
	map {$_->child($qc_stat_obj)} @same_sample_stat_obj;
	$qc_stat_obj->file($qcstat);
	push @commands,{
	    nCPU_requested	=>	1,
	    message		=>	"Generate QC stat",
	    command		=>	["$extractSummary ".
	    				join(" ",map{" -file ".$_->file." -alias ".&getAlias($_)} @same_sample_data_obj).
	    				" -out $qcstat"],
	    in			=>	[@same_sample_stat_obj],
	    out			=>	[$qc_stat_obj],
	}; 
	push @obj_list,$qc_stat_obj;
    }
}
sub bwa {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bwa=&getExe(&SeqMule::Utils::getProgramExe("bwa")); 
    my $runbwa=File::Spec->catfile($install_dir,"bin","secondary","runBWA");
    my $local_ref;
    my $aligner = "bwa";
    if ($ref) {
	$local_ref=$ref;
    } else {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","bwa",$local_ref);
	die "ERROR: No reference genome in $install_dir/database (did you download it?)\n" unless -f $original;
	symlink $original,$link unless -e $link;
	$local_ref=$link;
    }
    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$bwa,
	    alignerWrapper=>$runbwa,
	    ref=>$local_ref,
	    n	=>	$n,
	});
}
sub bwa_mem {
    #output example
    #./bwa mem -R '@RG\tID:foo\tSM:bar' -M -t 12 ~/projects/seqmule_main/database/bwa/human_g1k_v37.fasta ../s4.1.fastq ../s4.2.fastq
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bwa=&getExe(&SeqMule::Utils::getProgramExe("bwa")); 
    my $runBwamemCMD=File::Spec->catfile($install_dir,"bin","secondary","runBWA-MEM");
    my $local_ref;
    my $aligner = "bwamem";

    die "ERROR: BWA-MEM cannot handle Phred 64 base quality score\n" if $phred == 64;

    if ($ref) {
	$local_ref=$ref;
    } else {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","bwa",$local_ref);
	die "ERROR: No reference genome in $install_dir/database (did you download it?)\n" unless -f $original;
	symlink $original,$link unless -e $link;
	$local_ref=$link;
    }

    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$bwa,
	    alignerWrapper=>$runBwamemCMD,
	    ref=>$local_ref,
	    n	=>	$n,
	});
}

sub snap {
    #output example
    #./bwa mem -R '@RG\tID:foo\tSM:bar' -M -t 12 ~/projects/seqmule_main/database/bwa/human_g1k_v37.fasta ../s4.1.fastq ../s4.2.fastq
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $snap=&getExe(&SeqMule::Utils::getProgramExe("snap")); 
    my $runSnapCMD=File::Spec->catfile($install_dir,"bin","secondary","runSNAP");
    my $local_ref;
    my $aligner = "snap";

    die "ERROR: SNAP cannot handle Phred+64 score\n" if $phred == 64;

    if ($ref) {
	$local_ref=$ref;
    } else {
	$local_ref=($buildver eq 'hg19'? $HG19REF:$HG18REF);
	my $original=File::Spec->catfile($install_dir,"database",$local_ref);
	my $link=File::Spec->catfile($install_dir,"database","snap",$local_ref);
	$local_ref=$link;
    }
    #this part can be improved
    #SNAP can run multiple alignments without reloading index
    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$snap,
	    alignerWrapper=>$runSnapCMD,
	    ref=>$local_ref,
	    n	=>	$n,
	});
}
sub bowtie
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    my $bowtie=&getExe(&SeqMule::Utils::getProgramExe("bowtie")); 
    my $runBowtieCMD=File::Spec->catfile($install_dir,"bin","secondary","runBOWTIE");
    my $local_ref;
    my $aligner = "bowtie";
    #check if all indexes exist; keep the real name of the indexes
    if ($bowtie_index_prefix) {
	#bowtie index can also appear in bowtie dir, in env
	my $exe_folder=dirname(&SeqMule::Utils::abs_path_failsafe($bowtie));

	my @index_pres;
	push @index_pres, $bowtie_index_prefix,File::Spec->catfile($exe_folder,"indexes",$bowtie_index_prefix);
	push @index_pres, File::Spec->catfile($ENV{BOWTIE_INDEXES},$bowtie_index_prefix) if defined $ENV{BOWTIE_INDEXES};
	for (@index_pres) {
	    if (&index_check("bowtie",$_)) {
		$local_ref=$_;
		last;
	    }
	}
    } else {
	my ($hg18_pre)= $HG18REF=~/(.*)\.(.*)$/;
	my ($hg19_pre)= $HG19REF=~/(.*)\.(.*)$/;
	my $default_index=File::Spec->catfile($install_dir,"database","bowtie",($buildver eq 'hg18' ? $hg18_pre : $hg19_pre));
	$local_ref=$default_index;
    } 

    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$bowtie,
	    alignerWrapper=>$runBowtieCMD,
	    ref=>$local_ref,
	    n	=>	$n,
	});
}
sub bowtie2 {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $bowtie2=&getExe(&SeqMule::Utils::getProgramExe("bowtie2")); 
    my $runBowtie2CMD=File::Spec->catfile($install_dir,"bin","secondary","runBOWTIE2");
    my $local_ref;
    my $aligner = "bowtie2";

    #check if all indexes exist; keep the real name of the indexes
    if ($bowtie2_index_prefix)
    {
	#bowtie index can also appear in bowtie dir, in env
	my $exe_folder=dirname(&SeqMule::Utils::abs_path_failsafe($bowtie2));

	my @index_pres;
	push @index_pres, $bowtie2_index_prefix,File::Spec->catfile($exe_folder,"indexes",$bowtie2_index_prefix);
	push @index_pres, File::Spec->catfile($ENV{BOWTIE2_INDEXES},$bowtie2_index_prefix) if defined $ENV{BOWTIE2_INDEXES};
	for (@index_pres) {
	    if (&index_check("bowtie",$_)) {
		$local_ref=$_;
		last;
	    }
	}
    } else {
	my ($hg18_pre)= $HG18REF=~/(.*)\.(.*)$/;
	my ($hg19_pre)= $HG19REF=~/(.*)\.(.*)$/;
	my $default_index=File::Spec->catfile($install_dir,"database","bowtie2",($buildver eq 'hg18' ? $hg18_pre : $hg19_pre));
	$local_ref=$default_index;
    } 
    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$bowtie2,
	    alignerWrapper=>$runBowtie2CMD,
	    ref=>$local_ref,
	    n	=>	$n,
	});
}
sub soap {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe=&getExe(&SeqMule::Utils::getProgramExe("soap")); 
    my $runsoap=File::Spec->catfile($install_dir,"bin","secondary","runSOAP");
    my $local_ref;
    my $aligner = "soap";

    if ($soap_index_prefix) {
	$local_ref=$soap_index_prefix;
    } else {
	my $hg18_pre="$HG18REF.index";
	my $hg19_pre="$HG19REF.index";
	my $default_index=File::Spec->catfile($install_dir,"database","soap",($buildver eq 'hg18'? $hg18_pre:$hg19_pre));
	$local_ref=$default_index;
    } 
    &gen_aligner_cmd({
	    aligner=>$aligner,
	    alignerPath=>$exe,
	    alignerWrapper=>$runsoap,
	    ref=>$local_ref,
	    n	=>	$n,
	});
} 
sub gen_aligner_cmd {
    my $local_opt = shift;
    my $local_ref = $local_opt->{ref};
    my $aligner = $local_opt->{aligner};
    my $aligner_wrapper = $local_opt->{alignerWrapper};
    my $aligner_path = $local_opt->{alignerPath};
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools")); 
    my $n = $local_opt->{n};

    #check if all index files are present

    (defined $local_ref and &index_check($aligner,$local_ref)) or die "ERROR: $aligner index file(s) missing ($local_ref)\nConsider --no-check-idx if you use non-default reference genome.\n";
    warn "gen_aligner_cmd" if $debug;
    &check_obj(@obj_list) if $debug;
    for my $i(@obj_list) {
	next unless $i->filetype eq 'FASTQ' and $i->rank == 0;
	my $local_prefix= &SeqMule::Utils::getFQprefix($i->file());
	my @local_fq_obj = ($i,$i->sibling());
	my @local_fq;
	my $local_bam_obj = $i->clone();
	my $local_bam="${local_prefix}_$aligner.sort.bam";
	my @out_obj_list = ($local_bam_obj);
	my $cmd;

	$local_bam_obj->aligner($aligner);
	$local_bam_obj->file($local_bam);
	$local_bam_obj->parent(@local_fq_obj);
	$local_bam_obj->filetype('BAM');
	map{$_->child($local_bam_obj)} (@local_fq_obj);
	push @local_fq,map {$_->file()} (@local_fq_obj);

	$cmd.="$aligner_wrapper ";
	if($local_bam_obj->istumor) {
	    #so internally, tumor and normal samples with same prefix are considered as coming from same sample
	    #this is not ideal because tumor and normal samples should have different sample names
	    #but if they have different sample names, then we need to devise anotehr way to know they are a pair of samples
	    #to be used in somatic calling (e.g. add individual ID to obj??)
	    $cmd .= " -sample ".$local_bam_obj->sample()."_tumor";
	} else {
	    $cmd .= " -sample ".$local_bam_obj->sample();
	}
	$cmd .= " -rg ".$local_bam_obj->rg().
	" -pl ".$local_bam_obj->pl().
	" -lb ".$local_bam_obj->lb().
	" -tmpdir $TMPDIR".
	" -advanced $advanced -n $n ".
	" -bam ".$local_bam_obj->file().
	" -alignerPath $aligner_path ".
	" -samtools $samtools ".
	" -threads $threads".
	" -ref $local_ref ";
	map {$cmd .= " -fq $_ ";} @local_fq;

	if ($aligner eq 'soap') {
	    my $alnfile="${local_prefix}_${aligner}.soapaln";
	    my $local_soapaln_obj = $i->clone();
	    push @out_obj_list,$local_soapaln_obj;
	    my $exe_soap2sam = File::Spec->catfile($install_dir,"bin","soap2sam.pl");

	    $local_soapaln_obj->file($alnfile);
	    $local_soapaln_obj->parent(@local_fq_obj);
	    $local_soapaln_obj->filetype('SOAPALN');
	    $local_soapaln_obj->aligner($aligner);
	    map{$_->child($local_soapaln_obj)} (@local_fq_obj);

	    $cmd .= " -soap2sam $exe_soap2sam ";
	    $cmd.=" -soapaln $alnfile";

	    push @obj_list,$local_soapaln_obj;
	    push @removable,$local_soapaln_obj;
	} elsif ($aligner eq 'snap') {
	    my $interleave_fq = &getExe(&SeqMule::Utils::getProgramExe("interleave_fastq"));
	    $cmd .= " -interleave_fq $interleave_fq ";
	}
	push @commands,{
	    nCPU_requested	=>	$threads,
	    message		=>	"$aligner alignment",
	    command		=>	[$cmd],
	    in			=>	[@local_fq_obj],
	    out			=>	[@out_obj_list],
	};
	push @obj_list,$local_bam_obj;
	push @removable,$local_bam_obj;
    }
}
sub samtools {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $faidx="$local_ref.fai";
	warn "NOTICE: indexing reference, this may take a while.\n" and !system("$exe faidx $local_ref") or die "ERROR: failed to index $local_ref\n" if not -e $faidx;
    if ($subprogram=~/index/i) {
	if ($merge) {
	    #merge by aligner, sample combination
	    for my $i(&get_aligner) {
		for my $j(0..$#prefix_list) {
		    my $sample = $prefix_list[$j];
		    my $result_folder = &get_result_folder($sample);
		    my $onebam = File::Spec->catfile($result_folder,$sample."_$i.merge.bam");
		    my @one_aligner_sample_bam = grep {
		    $_->aligner() eq $i && 
		    $_->filetype eq 'BAM' &&
		    $_->sample() eq $sample &&
		    #here we assume that all ancestors are of the same file type
		    (($_->ancestor())[0])->filetype() eq 'FASTQ'
		    } @obj_list;
		    #remove the unmerged BAM from obj_list
		    #they will no longer be processed
		    SeqMule::SeqUtils->rmObjFromArray(
			target=>\@one_aligner_sample_bam,
			all=>\@obj_list,
		    );

		    my $onebam_obj = $one_aligner_sample_bam[0]->clone();
		    $onebam_obj->parent(@one_aligner_sample_bam);
		    $onebam_obj->file($onebam);
		    map {$_->child($onebam_obj) } @one_aligner_sample_bam;

		    if(@one_aligner_sample_bam == 1) {
			push @commands, {
			    nCPU_requested	=>	1,
			    message		=>	"Merge BAM by $i and $sample",
			    command		=>	[
				join(" ","cp",$one_aligner_sample_bam[0]->file(),$onebam_obj->file()),
				"$exe index ".$onebam_obj->file,
			    ],
			    in			=>	[@one_aligner_sample_bam],
			    out			=>	[$onebam_obj],
			};
		    } else {
			push @commands, {
			    nCPU_requested	=>	$threads,
			    message		=>	"Merge BAM by $i and $sample",
			    command		=>	[
			    "$exe merge -f ".$onebam_obj->file().' '.join(' ',map{$_->file()} @one_aligner_sample_bam).($threads>=2? " -@ $threads ":" "),
			    "$exe index ".$onebam_obj->file,
			],
			    in			=>	[@one_aligner_sample_bam],
			    out			=>	[$onebam_obj],
			};
		    }
		    #save merged obj in obj_list
		    push @obj_list,$onebam_obj; 
		    push @removable,$onebam_obj;
		}
	    }
	}
    } elsif($subprogram=~/filter/i) {
	my $readfilter=File::Spec->catfile($install_dir,"bin","secondary","readFilter");
	for my $i(@obj_list) {
	    next unless $i->filetype eq 'BAM';
	    my $bam = $i->file();
	    my ($local_prefix)= $bam=~/(.*?)\.bam$/i or die "ERROR: expect .bam suffix: $bam\n";
	    my $new_obj = $i->clone();
	    my $out="$local_prefix.readfiltered.bam";
	    $new_obj->parent($i);
	    $new_obj->file($out);
	    $i->child($new_obj);

	    my $cmd="$readfilter -samtools $exe -bam $bam -out $out -threads $threads -n $n -advanced $advanced ";
	    push @commands, {
		nCPU_requested	=>	$threads,
		message		=>	"Filter BAM file by mapping quality",
		command		=>	[$cmd],
		in		=>	[$i],
		out		=>	[$new_obj],
	    };
	    push @removable,$i; #this bam is no long essential for downstream analysis, can be deleted at user's discretion
	    $i=$new_obj;
	}
    }elsif ($subprogram=~/mpileup/i) {
	my $mode;
	my $caller = 'samtools';
	my $bcftools=&getExe("bcftools");
	my $vcfutils=&getExe("vcfutils.pl");
	my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","runSAMTOOLS");
	my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $faidx="$local_ref.fai";
	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
	my $cmd_common="$exe -advanced $advanced -n $n -samtools $samtools -bcftools $bcftools -vcfutils $vcfutils -ref $local_ref -tmpdir $TMPDIR ";

	#add PATH for bcftools
	$ENV{PATH}=($ENV{PATH}? $ENV{PATH}.":":"").File::Spec->catdir(dirname($samtools),"bcftools");
	warn "NOTICE: indexing reference, this may take a while.\n" and !system("$samtools faidx $local_ref") or die "samtools faidx failed: $!\n" if not -e $faidx;
	warn "NOTICE: SAMtools will enable mapping quality downgrading for BWA input (if any).\n" if ($options{bwaDownGrade});

	my @target_obj;
	if ($options{'originalBAM'}) {
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else {
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	    die "ERROR: \@target_obj empty for $caller, make sure recalibration and realignment is enabled while\n".
	    "originalBAM is NOT in use. Or you can turn on originalBAM.\n" unless @target_obj;
	}

	#previously we have to treat BAMs differently depending on
	#whether they come from FASTQ files
	#now we solely depend on aligner of each BAM
	#if it comes from FASTQ, it has an non-empty string denoting the aligner
	#otherwise its aligner attribute is an empty string ''
	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
	{
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;
	    &gen_variant_call_cmd({
		    caller=>$caller,
		    callcmd=>$cmd_common,
		    bam=>\@bam_obj
		});
	}
    } elsif ($subprogram=~/rmdup/i) {
	for my $i(@obj_list) {
	    next unless $i->filetype() eq 'BAM';
	    my $bam = $i->file();
	    my ($local_prefix)= $bam=~/(.*?)\.bam$/i or die "ERROR: expect .bam suffix: $bam\n";
	    my $new_obj = $i->clone();
	    my $out = "$local_prefix.rmdup.bam";
	    $new_obj->parent($i);
	    $new_obj->file($out);
	    $i->child($new_obj);

	    my $cmd.="$exe rmdup $bam $out";
	    push @commands,{
		nCPU_requested		=>	1,
		message			=>	"Remove duplicates in $bam",
		command			=>	[$cmd],
		in			=>	[$i],
		out			=>	[$new_obj],
	    };
	    push @removable,$i; #this bam is no long essential for downstream analysis, can be deleted at user's discretion
	    $i = $new_obj;
	}
    }else {die "ERROR: Unrecognized subprogram for SAMtools: $subprogram\n"}
}
sub freebayes {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $caller='freebayes';
    my $run_freebayes=&getExe("runFREEBAYES");
    my $freebayes=&getExe( &SeqMule::Utils::getProgramExe("Freebayes") );
    my $samtools=&getExe( &SeqMule::Utils::getProgramExe("samtools") );
    my $vcfsorter = File::Spec->catfile($install_dir,"bin","secondary","vcfsorter");
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
    my $cmd_common="$run_freebayes -advanced $advanced -n $n -freebayes $freebayes -vcfsorter $vcfsorter -ref $local_ref -samtools $samtools -tmpdir $TMPDIR ";

    my @target_obj;
    if ($options{'originalBAM'})
    {
	#this step is to make sure we use BAM files without realn or recal if users want to
	@target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
    } else {
	@target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	die "ERROR: \@target_obj empty for $caller, make sure recalibration and realignment is enabled while\n".
	"originalBAM is NOT in use. Or you can turn on originalBAM.\n" unless @target_obj;
    }

    #previously we have to treat BAMs differently depending on
    #whether they come from FASTQ files
    #now we solely depend on aligner of each BAM
    #if it comes from FASTQ, it has an non-empty string denoting the aligner
    #otherwise its aligner attribute is an empty string ''
    for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
    {
	#do multi-sample calling for bam files from the same aligner
	my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	@bam_obj = grep {$_->aligner eq $i} @bam_obj;
	&gen_variant_call_cmd({
		caller=>$caller,
		callcmd=>$cmd_common,
		bam=>\@bam_obj
	    });
    }
}

########################gatklite################################
sub gatk
{
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};

    if ($subprogram=~/realign/i) { warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } &get_aligner);

	&gen_gatk_realign_recal_cmd($n,"gatklite","realn",\%options);
    } elsif ($subprogram=~/recal/i) {
	warn "CAUTION: GATKLite base quality reclibration COVARIATE options will not be examined for syntax\n" if $options{covariates};
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } &get_aligner);
	die "ERROR: No covariates for base quality recalibration\n" if $options{covariates} eq "";

	&gen_gatk_realign_recal_cmd($n,"gatklite","recal",\%options);
    } 
    elsif ($subprogram=~/variant/) 
    {
	my $caller='gatklite';
	my $mode;
	my $exe=&getExe(&SeqMule::Utils::getProgramExe("gatklite"));
	my $runGATKCMDFILTER=File::Spec->catfile($install_dir,"bin","secondary","runGATKLITEFILTER");
	my $runGATKCMDCALL=File::Spec->catfile($install_dir,"bin","secondary","runGATKLITECALL");

	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
	my $local_hapmap=&SeqMule::Utils::search_db({type=>"hapmap",target=>$hapmap,build=>$buildver,install_dir=>$install_dir});
	my $local_kg=&SeqMule::Utils::search_db({type=>"kg",target=>$kg,build=>$buildver,install_dir=>$install_dir});
	my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});

	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
	#sanity check for filter expression
	for my $i($options{indelfilters}, $options{snpfilters})
	{
	    for my $filter(split ';',$i)
	    {
		my ($filtername,$filterexp)=split ',',$filter;
		die "Missing filter name or expression for GATKLite indel/SNP filtering.\n" unless ($filtername && $filterexp);
	    }
	}
	my $cmd_common_filter="$runGATKCMDFILTER -advanced $advanced  -n $n -gatk-hfilter-size $GATKLITE_HARD_FILTER_BAM_SIZE -gatk-indelfilter-size $GATKLITE_INDEL_HARD_FILTER_BAM_SIZE -ref $local_ref -hapmap $local_hapmap -kg $local_kg -dbsnp $local_dbsnp -goldindel $local_indel -java $jexe -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt --tmpdir $TMPDIR ";
	my $cmd_common_call="$runGATKCMDCALL -advanced $advanced  -n $n -ref $local_ref -java $jexe -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
	warn "CAUTION: GATKLite variant recalibration annotation options will not be examined for syntax\n" if $options{annotations} ne "";
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATKLite\n" and sleep 1 if (grep { /soap/ } (SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)));

	my @target_obj;

	warn "gatk lite\n" if $debug;
	check_obj(@obj_list) if $debug;
	warn "1384" if $debug;

	if ($options{'originalBAM'}) {
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else {
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	    die "ERROR: \@target_obj empty for $caller, make sure recalibration and realignment is enabled while\n".
	    "originalBAM is NOT in use. Or you can turn on originalBAM.\n" unless @target_obj;
	}
	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)) {
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;

	    warn "gatk lite target: $i\n" if $debug;
	    check_obj(@bam_obj) if $debug;
	    &gen_variant_call_cmd({
		    caller		=>	$caller,
		    callcmd		=>	$cmd_common_call,
		    filtercmd		=>	$options{filter} ? $cmd_common_filter: undef,
		    bam			=>	\@bam_obj,
		});
	}
    } else { 
	die "ERROR: Unrecognized subprogram $subprogram for GATKLite.\n";
    }
}

sub gen_gatk_realign_recal_cmd {
    warn "1455\n" if $debug;
    &check_obj(@obj_list) if $debug;
    my $n = shift;
    my $version = shift; #gatklite vs gatkfull?
    my $operation = shift; #realn vs recal
    my %options=%{shift @_};
    my $exe;
    my $exe_samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});
    my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
    my $run_gatk;
    my @newbam_obj_list;

    if($version eq 'gatklite') {
	$exe = &getExe(&SeqMule::Utils::getProgramExe("gatklite"));
	if($operation eq 'realn') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKLITEREALN");
	} elsif ($operation eq 'recal') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKLITERECAL");
	} else {
	    die "ERROR: unknown GATK operation: $operation\n";
	}
    } elsif ($version eq 'gatkfull') {
	$exe = &getExe(&SeqMule::Utils::getProgramExe("gatk"));
	if($operation eq 'realn') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLREALN");

	} elsif ($operation eq 'recal') {
	    $run_gatk = File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLRECAL");
	} else {
	    die "ERROR: unknown GATK operation: $operation\n";
	}
    } else {
	die "ERROR: unknown GATK version: $version\n";
    }

    my $cmd_common ="$run_gatk -advanced $advanced -n $n -ref $local_ref -java $jexe -jmem $java_mem -gatk $exe -threads $threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
    $cmd_common .= " -bed $capture" if $wes;
    $cmd_common .= " -goldindel $local_indel " if $local_indel;
    $cmd_common .= " -dbsnp $local_dbsnp " if $local_dbsnp;
    $cmd_common .= " -samtools $exe_samtools ";

    for my $local_bam_obj(@obj_list) {
	warn "1500\n" if $debug;
	&check_obj($local_bam_obj) if $debug;
	if($local_bam_obj->filetype() ne 'BAM' or
	    ($local_bam_obj->realn && $operation eq 'realn') or
	    ($local_bam_obj->recal && $operation eq 'recal') ) { 
	    #if an obj has a child, then it is not the latest obj generated
	    #NOT necessarily TRUE!!!
	    #($local_bam_obj->child() >= 1) ) { 
	    next;
	}
	next unless $local_bam_obj->filetype() eq 'BAM';
	my $local_bam = $local_bam_obj->file();
	my ($local_prefix)=$local_bam=~/(.*)\.bam$/i;
	my $newbam_obj = $local_bam_obj->clone();
	my $newbam = "${local_prefix}.$operation.bam";
	my $cmd = $cmd_common;

	$cmd .= " -pl ".$local_bam_obj->pl()." " if $local_bam_obj->pl();
	if($operation eq 'realn') {
	    $newbam_obj->realn(1);
	} elsif ($operation eq 'recal') {
	    $newbam_obj->recal(1);
	}
	$newbam_obj->file($newbam);
	$newbam_obj->parent($local_bam_obj);
	$local_bam_obj->child($newbam_obj);

	$cmd .= " -bam $local_bam -out $newbam ";
	push @commands,{
	    nCPU_requested	=>	$threads,
	    message		=>	"$version $operation",
	    command		=>	[$cmd],
	    in			=>	[$local_bam_obj],
	    out			=>	[$newbam_obj],
	};
	#it's possible that some variant callers will use non-recal non-realn BAM
	#so we still keep the old BAM in @obj_list
	if($local_bam_obj->realn == 1 || $local_bam_obj->recal == 1) {
	    $local_bam_obj = $newbam_obj;
	} else {
	    push @obj_list,$newbam_obj;

	}
	#$local_bam_obj = $newbam_obj; 
	warn "1483" if $debug;
	#push @newbam_obj_list,$newbam_obj;
	push @removable,$newbam_obj;
    }
    warn "1546" if $debug;
    &check_obj(@obj_list) if $debug;
}
#############end of gatklite#############

#################################gatk full version###########################
sub gatk_full {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    $subprogram=lc $subprogram;

    if ($subprogram eq 'realign') {
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK\n" and sleep 1 if (grep { /soap/ } &get_aligner);

	&gen_gatk_realign_recal_cmd($n,"gatkfull","realn",\%options);
    } elsif ($subprogram eq 'recal') {
	warn "CAUTION: GATK base quality reclibration COVARIATE options will not be examined for syntax\n" if $options{covariates};
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK\n" and sleep 1 if (grep { /soap/ } &get_aligner);
	die "ERROR: No covariates for base quality recalibration\n" if $options{covariates} eq "";

	&gen_gatk_realign_recal_cmd($n,"gatkfull","recal",\%options);
    } elsif ($subprogram eq 'unifiedgenotyper' || $subprogram eq 'haplotypecaller') {
	my $mode;
	my $exe=&getExe(&SeqMule::Utils::getProgramExe("gatk"));
	my $runGATKCMDCALL=File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLCALL");
	my $runGATKCMDFILTER=File::Spec->catfile($install_dir,"bin","secondary","runGATKFULLFILTER");

	my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	my $local_dbsnp=&SeqMule::Utils::search_db({type=>"dbsnp",target=>$dbsnp,build=>$buildver,version=>$dbsnpver,install_dir=>$install_dir});
	my $local_hapmap=&SeqMule::Utils::search_db({type=>"hapmap",target=>$hapmap,build=>$buildver,install_dir=>$install_dir});
	my $local_kg=&SeqMule::Utils::search_db({type=>"kg",target=>$kg,build=>$buildver,install_dir=>$install_dir});
	my $local_indel=&SeqMule::Utils::search_db({type=>"indel",target=>$indel,build=>$buildver,install_dir=>$install_dir});

	my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1

	#sanity check for filter expression
	for my $i($options{indelfilters}, $options{snpfilters})
	{
	    for my $filter(split ';',$i)
	    {
		my ($filtername,$filterexp)=split ',',$filter;
		die "Missing filter name or expression for GATK indel/SNP filtering.\n" unless ($filtername && $filterexp);
	    }
	}

	my $cmd_common_call="$runGATKCMDCALL -internal-caller $subprogram -advanced $advanced -n $n -ref $local_ref -java $jexe -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt -tmpdir $TMPDIR ";
	my $cmd_common_filter="$runGATKCMDFILTER -internal-caller $subprogram -advanced $advanced -n $n -gatk-hfilter-size $GATK_HARD_FILTER_BAM_SIZE  -gatk-indelfilter-size $GATK_INDEL_HARD_FILTER_BAM_SIZE -ref $local_ref -hapmap $local_hapmap -kg $local_kg  -dbsnp $local_dbsnp -goldindel $local_indel -java $jexe -jmem $java_mem -gatk $exe -threads $local_threads -gatk-nt $gatk_nt --tmpdir $TMPDIR ";

	warn "CAUTION: GATK variant recalibration annotation options will not be examined for syntax\n" if $options{annotations} ne "";
	warn "CAUTION: SOAPaligner output might not be able to be processed by GATK UnifiedGenotyper.\n" and sleep 1 if (grep { /soap/ } &get_aligner);
	my @target_obj;
	my $caller=$subprogram eq 'unifiedgenotyper'?'gatk_ug':'gatk_hc';

	warn "1562" if $debug;
	check_obj(@obj_list) if $debug;
	if ($options{'originalBAM'}) {
	    #this step is to make sure we use BAM files without realn or recal if users want to
	    @target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
	} else {
	    @target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	    die "ERROR: \@target_obj empty for $caller, make sure recalibration and realignment is enabled while\n".
	    "originalBAM is NOT in use. Or you can turn on originalBAM.\n" unless @target_obj;
	}

	for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list)) {
	    #do multi-sample calling for bam files from the same aligner
	    my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	    @bam_obj = grep {$_->aligner eq $i} @bam_obj;

	    &gen_variant_call_cmd({
		    caller		=>	$caller,
		    callcmd		=>	$cmd_common_call,
		    filtercmd		=>	$options{filter} ? $cmd_common_filter: undef,
		    bam			=>	\@bam_obj,
		});
	}
    } else
    { 
	die "ERROR: Unrecognized subprogram $subprogram for GATK\n";
    }
}

############end of gatk full version##########

sub picard {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $exe=&getExe("markduplicates.jar");
    if ($subprogram=~/markduplicates/i) {
	for my $local_bam_obj(@obj_list) {
	    next unless $local_bam_obj->filetype() eq 'BAM';
	    my $cmd;
	    my $local_bam = $local_bam_obj->file();
	    my ($local_prefix)= $local_bam =~ /(.*)\.bam$/i;
	    my $newbam_obj = $local_bam_obj->clone();
	    my $newbam="$local_prefix.rmdup.bam";
	    my $metrics="${local_prefix}.rmdup.metrics";
	    $newbam_obj->file($newbam);
	    $newbam_obj->parent($local_bam_obj);
	    $local_bam_obj->child($newbam_obj);
	    #only mark duplicates, do not really remove them from BAM
	    $cmd.="$jexe ";
	    $cmd.=" -Djava.io.tmpdir=$TMPDIR " if $TMPDIR;
	    $cmd.=" -Xmx$java_mem -jar $exe INPUT=$local_bam OUTPUT=$newbam METRICS_FILE=$metrics REMOVE_DUPLICATES=false VALIDATION_STRINGENCY=SILENT";
	    push @commands,{
		nCPU_requested		=>	$threads,
		message			=>	"Remove duplicates",
		command			=>	[$cmd],
		in			=>	[$local_bam_obj],
		out			=>	[$newbam_obj],
	    };
	    $local_bam_obj = $newbam_obj;
	    push @removable,$newbam_obj;
	}
    } else {
	die "ERROR: Unrecognized subprogram for picard: $subprogram\n";
    }
}
sub varscan {
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $mode;
    my $caller = 'varscan';
    my $exe=File::Spec->catfile($install_dir,"bin","secondary","runVARSCAN");
    my $varscan=&getExe(&SeqMule::Utils::getProgramExe("varscan"));
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $cmd_common="$exe -advanced $advanced -n $n -samtools $samtools -java $jexe -jmem $java_mem -varscan $varscan -ref $local_ref -tmpdir $TMPDIR ";

    my @target_obj;

    if ($options{'originalBAM'}) {
	#this step is to make sure we use BAM files without realn or recal if users want to
	@target_obj = grep {$_->realn() == 0 && $_->recal() == 0} @obj_list;
    } else {
	@target_obj = grep {$_->realn() == 1 || $_->recal() == 1} @obj_list;
	die "ERROR: \@target_obj empty for $caller, make sure recalibration and realignment is enabled while\n".
	"originalBAM is NOT in use. Or you can turn on originalBAM.\n" unless @target_obj;
    }
    $mode = $multi_sample_calling? 'multi':($somatic_toggle? 'somatic':'single');

    for my $i(SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list))
    {
	#do multi-sample calling for bam files from the same aligner
	my @bam_obj = grep {$_->filetype eq 'BAM'} @target_obj;
	@bam_obj = grep {$_->aligner eq $i} @bam_obj;
	&gen_variant_call_cmd({
		caller=>$caller,
		callcmd=>$cmd_common,
		bam=>\@bam_obj
	    });
    }
} 
sub gen_variant_call_cmd {
    #for varscan, samtools and freebayes and GATK
    #figure out the mode of variant calling: multi-sample, somatic, single-sample
    #figure out what BAMs to use
    #call gen_cmd_for_variant_call_task to actually generate the command
    my $opt = shift;
    my $mode = $multi_sample_calling? 'multi':($somatic_toggle? 'somatic':'single');
    my $caller = $opt->{caller};
    my $cmd_common = $opt->{callcmd};
    my $cmd_common_filter = $opt->{filtercmd};
    my @bam_obj = @{$opt->{bam}};
    warn "1733: mode: $mode for $caller\n" if $debug;
    while(@bam_obj) {
	#number of tasks, when quick is enabled, equal to number of threads
	my $ntask = $quick ? $total_threads : 1;
	my @bam_obj_for_this_task;
	my $suffix;
	#after we process a BAM, we remove it from the list to be processed
	if($mode eq 'multi') {
	    @bam_obj_for_this_task = @bam_obj;
	    @bam_obj = ();
	    die "ERROR: expect at least 2 BAM files for multi-sample variant calling.\n" unless @bam_obj_for_this_task >= 2;
	    $suffix = $caller.".multi-call";
	} elsif ($mode eq 'single') {
	    @bam_obj_for_this_task = shift @bam_obj;
	    $suffix = $caller;
	} elsif ($mode eq 'somatic') {
	    die "ERROR: Only VarScan and SAMtools support somatic variant calling: $caller\n" if $caller ne 'varscan' and $caller ne 'samtools';
	    $suffix = $caller.".somatic-call";
	    #for somatic calling, we need a pair of BAM, normal and tumor
	    my $random_obj = shift @bam_obj;
	    #before calling gen_variant_call_cmd, we have make sure
	    #the BAM files come from same aligner
	    my @same_sample_obj = grep { $_->sample() eq $random_obj->sample() } @bam_obj;

	    if(@same_sample_obj == 1) {
		#here we put normal first, tumor second
		if($random_obj->istumor() == 0 && $same_sample_obj[0]->istumor() == 1) {
		    push @bam_obj_for_this_task,$random_obj,$same_sample_obj[0];
		} elsif ($random_obj->istumor() == 1 && $same_sample_obj[0]->istumor() == 0) {
		    push @bam_obj_for_this_task,$same_sample_obj[0],$random_obj;
		}
		#remove somatic/normal pair from input list
		SeqMule::SeqUtils->rmObjFromArray(
		    target=>\@same_sample_obj,
		    all=>\@bam_obj
		);
	    } elsif(@same_sample_obj == 0) {
		die "ERROR: only found one BAM file for sample ".$random_obj->sample()."\n".
		"Somatic mutation calling cannot be performed\n";
	    } else {
		die "ERROR: Right now SeqMule can only handle 2 BAM files for one sample in\n".
		"somatic calling mode, we found ".(scalar @same_sample_obj+1)."\n";
	    }
	} else    {
	    die "ERROR: unrecognized mode ($mode) for variant calling.\n";
	}
	my @sample_for_this_task = SeqMule::SeqUtils->get_attr_enum('sample',@bam_obj_for_this_task); 
	my @sibling_vcf = map {[]} (scalar @sample_for_this_task);
	for my $i(0..($ntask-1)) {
	    my $bed = $quick? $small_bed[$i]:$capture;
	    #the empty array ref will be used to store VCF files for all VCF obj
	    #generated by one task

	    &gen_cmd_for_variant_call_task({
		    bed=>$bed,
		    bam=>\@bam_obj_for_this_task,
		    sibling_vcf=>\@sibling_vcf,
		    cmd		=>$cmd_common,
		    filter_flag	=>	0,
		    caller	=>	$caller,
		    suffix	=> 	$suffix,
		    task_idx	=>	$i,
		}
	    );
	}
	#VCF generated in each task is a sibling
	#to VCFs generated in all other tasks given that sample/input BAM is same
	#later all VCFs which are siblings to each will be merged
	for my $i(0..$#sibling_vcf) {
	    for my $j(@{$sibling_vcf[$i]}) {
		$j->sibling(@{$sibling_vcf[$i]});
	    }
	}
	if($cmd_common_filter) {
	    #if a separate filtering is to be done
	    #we can safely remove obj generated in variant calling stage
	    SeqMule::SeqUtils->rmObjFromArray(
		target	=>	[map {@$_} @sibling_vcf],
		all	=>	\@obj_list,
	    );

	    #if filter is necessary
	    #we have to provide all siblings
	    #do filtering just once, then copy results
	    #to other samples (if any)
	    &gen_cmd_for_variant_call_task({
		    #here we will not use split BED
		    #as the filtering step cannot be carried out
		    #as multiple processes
		    bed		=>	$capture,
		    bam		=>	\@bam_obj_for_this_task,
		    sibling_vcf	=>	\@sibling_vcf,
		    cmd		=>	$cmd_common_filter,
		    caller	=>	$caller,
		    suffix	=> 	$suffix,
		    filter_flag	=>	1,
		    task_idx	=>	0,
		});
	}
    }
}

sub gen_cmd_for_variant_call_task
{
    #generate command and objects for variant calling/filtering step
    my $opt = shift;
    my $bed = $opt->{bed};
    my @bam_obj = @{$opt->{bam}};
    my @sibling_vcf = @{$opt->{sibling_vcf}};
    my @sample = SeqMule::SeqUtils->get_attr_enum('sample',@bam_obj); 
    my $cmd_common = $opt->{cmd};
    my $filter_flag = $opt->{filter_flag};
    my $suffix = $opt->{suffix};
    my $caller = $opt->{caller};
    my $i = $opt->{task_idx};
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1

    #@sibling_vcf will keep track of siblings of each VCF
    #first array size is equal to # of samples
    #second array size is equal to # of tasks
    #creation and completion of this array is done outside this subroutine
    #
    #here we want to create a VCF for 
    #each sample
    for my $j(0..$#sample) {
	my ($bam_obj_for_this_sample) = grep { $_->sample() eq $sample[$j] } @bam_obj;
	my ($local_prefix) = ($bam_obj_for_this_sample->file() =~ /(.*)\.bam$/i);
	$local_prefix = $local_prefix.".$i";
	my $local_vcf = "${local_prefix}_$suffix.vcf";  
	#my $local_vcf_filter = "${local_prefix}_$suffix.filter.vcf"; 

	#we create a VCF object for each sample
	#but only use the first one in analysis
	#the rest are just copies
	#name of this obj contains 'filter',
	#but it is not necessarily filtered depending on 
	#$cmd_common_filter

	my $new_vcf_obj = $bam_obj_for_this_sample->clone();
	$new_vcf_obj->filetype('VCF');
	$new_vcf_obj->caller($caller);

	$new_vcf_obj->file($local_vcf);
	if($filter_flag) {
	    #$new_vcf_obj->file($local_vcf_filter);
	} else {
	    #$new_vcf_obj->file($local_vcf);
	    #if a seperate filtering is performed
	    #then this VCF will NOT have siblings
	    #all siblings must have been merged before filtering
	    #otherwise why not do variant calling and filtering in the same step?
	    $new_vcf_obj->rank($i);
	}
	#only the first one is child of BAM input
	if($j==0) {
	    my @input_obj;
	    my $msg = $suffix; 
	    my $cmd = $cmd_common;
	    #$cmd.=" -vcf $local_vcf -vcf-filter $local_vcf_filter ";
	    $cmd.=" -vcf $local_vcf ";
	    $cmd.=" -bed $bed " if $bed;
	    if($filter_flag) {
		#parent is all sibling VCFs from variant calling step
		$new_vcf_obj->parent(@{$sibling_vcf[$j]});
		for my $p($new_vcf_obj->parent()) {
		    $cmd.=" -vcf-part ".$p->file();
		    #remove all but the first file
		    push @script_unlink_list, $p->file() if $p->file() ne $local_vcf;
		}
		$msg .= " variant filtering";
	    } else {
		$new_vcf_obj->parent(@bam_obj);
		map {$cmd.=" -bam ".$_->file()} @bam_obj;#use @bam_obj rather tahn new_vcf_obj->parent because we want to reserve the order(for somatic calling)
		$msg .= " variant calling";
	    }
	    map { $_->child($new_vcf_obj) } $new_vcf_obj->parent();
	    $cmd .= " -callSomatic" if (grep{$_->istumor == 1} $new_vcf_obj->parent) > 0;
	    push @commands,{
		nCPU_requested	=>	$local_threads,
		message		=>	$msg,
		command		=>	[$cmd],
		in		=>	[$new_vcf_obj->parent],
		out		=>	[$new_vcf_obj],
	    };
	} else {
	    #for each BAM, variants are only called once
	    #the rest of VCFs are generated by copy if two VCFs share same input
	    my $vcf_template = $sibling_vcf[0][$i];
	    $new_vcf_obj->parent($vcf_template);
	    $vcf_template->child($vcf_template->child(),$new_vcf_obj);
	    #this step is necessary because result for each sample is supposed to be standalone
	    push @commands,{
		nCPU_requested		=>	$local_threads,
		message			=>	"Copy results to other samples",
		command			=>	["cp ".$vcf_template->file()." ".$new_vcf_obj->file()],
		in			=>	[$vcf_template],
		out			=>	[$new_vcf_obj],
	    };
	}
	#note the index here is sample idx then task idx
	#VCFs of same sample idx will be siblings/merged later
	$sibling_vcf[$j][$i] = $new_vcf_obj;
	push @obj_list,$new_vcf_obj;
    }
}
sub soapsnp {
    warn "soapsnp cmd generation\n" if $verbose;
    my ($n,$program,$subprogram,$opt_ref)=@_;
    my %options=%{$opt_ref};
    my $soapsnp=&getExe(&SeqMule::Utils::getProgramExe("soapsnp"));
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $soapsnp2vcf=File::Spec->catfile($install_dir,"bin","soapsnp2vcf");
    my $msort=&getExe("msort");
    my $runSoapsnp=File::Spec->catfile($install_dir,"bin","secondary","runSOAPSNP");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $local_threads=($quick? 1 : $threads); #if quick mode, define a local version of $threads, set it to 1
    my $cmd_common .= "$runSoapsnp -advanced $advanced -n $n -msort $msort -soapsnp $soapsnp -samtools $samtools -soapsnp2vcf $soapsnp2vcf -ref $local_ref ";
    my $caller = "soapsnp";

    die "ERROR: $caller does NOT support somatic calling.\n" if $somatic_toggle;
    for my $soap_obj(@obj_list) {
	next unless $soap_obj->filetype() eq 'SOAPALN';
	my $soap_file = $soap_obj->file();
	my ($local_prefix) = $soap_file=~/(.*)\.soapaln$/i; 
	my $outfile = "${local_prefix}_$caller.consensus"; 
	my $vcf = "${local_prefix}_$caller.filter.vcf"; 
	my $sorted = "${local_prefix}.sort.soapaln"; 
	my $sample = $soap_obj->sample();
	my ($bam_obj) = grep {$_->sample() eq $sample and $_->filetype() eq 'BAM'} @obj_list;
	my $new_vcf_obj = $soap_obj->clone();
	my $new_soapaln_obj = $soap_obj->clone();
	my $cmd;

	$new_vcf_obj->caller($caller);
	$new_vcf_obj->file($vcf);
	$new_soapaln_obj->file($sorted);
	$new_vcf_obj->filetype('VCF');
	$new_soapaln_obj->filetype('SOAPALN');
	$new_vcf_obj->parent($soap_obj);
	$new_soapaln_obj->parent($soap_obj,$bam_obj);
	$soap_obj->child($new_soapaln_obj,$new_vcf_obj);

	$cmd .= $cmd_common;
	$cmd .= " -in $soap_file ";
	$cmd .= " -bam ".$bam_obj->file();
	$cmd .= " -sample $sample ";
	$cmd .= " -sorted $sorted ";
	$cmd.=" -soapsnp-out $outfile -vcf $vcf ";

	push @commands,{
	    nCPU_requested		=>	$local_threads,
	    message			=>	"SOAPsnp variant calling",
	    command			=>	[$cmd],
	    in				=>	[$new_vcf_obj->parent],
	    out				=>	[$new_vcf_obj,$new_soapaln_obj],
	};
	push @script_unlink_list,$outfile;
	push @obj_list,$new_vcf_obj;
	#the unsorted soapaln file is no longer usefu
	$soap_obj = $new_soapaln_obj;
    }
} 

sub genScript {
    warn "Generating script...\n";
    #prepare new tmp folder
    if ($quick) {
	if ($wes) {
	    @small_bed=&SeqMule::Utils::splitRegion({threads=>$total_threads,bed=>$capture,prefix=>$analysis_prefix});
	} else {
	    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
	    my $bed=$capture || &SeqMule::Utils::fa2BED($local_ref);
	    @small_bed=&SeqMule::Utils::splitRegion({bed=>$bed,threads=>$total_threads});
	}
	#remove temp BED files after analysis is done
	push @script_unlink_list,@small_bed;
    }
#convert phred64 to phred33, only effective for FQ input
    &convert64to33();

    #read advanced_config file, generate command array
    &parsePipeline();

    &mergeVCF();

    &extractVar if $wes;

    &getConsensusCall();

#output venn, align stats, variant stats, fastqc stats
    &genStat() unless $nostat;
#copy all results of each individual sample to one folder

    unless ($noremove) {
	my @removable_files = &keepUseful;
	push @commands,{
	    nCPU_requested		=>	1,
	    message			=>	"Remove intermediate files",
	    command			=>	["rm -f @removable_files"],
	    in				=>	[@removable],
	    out				=>	[],
	} if (@removable);
    }
    if (@script_unlink_list) {
	#-f makes rm keep silent if the file doesn't exist
	push @commands,{
	    nCPU_requested		=>	1,
	    message			=>	"Remove temporary files",
	    command			=>	["rm -rf @script_unlink_list"],
	    in				=>	[@obj_list],
	    out				=>	[],
	}
    }
    &writeLog;
    &genReport() unless ($nostat);
    #generate analysis script
    &writeScript();
}
sub keepUseful {
    my @index_files;
    my @removable_files;
    for (@removable) {
	push @index_files,"$1.bai" if $_->file =~ /(.*?)\.bam$/i;
	push @index_files,"$1.idx" if $_->file =~ /(.*?)\.vcf$/i;
    }
    push @removable_files,@index_files;
    return @removable_files;
}
sub genReport {
    my $outdir="${analysis_prefix}_report";
    warn "NOTICE: report folder will be overwritten: $outdir\n" if -d $outdir;
    my $param_file=File::Spec->catfile($outdir,"parameter.txt");
    my $log_file=File::Spec->catfile($outdir,"log.txt");
    my $html_gen=File::Spec->catfile($install_dir,"bin","secondary","html_gen");
    mkdir $outdir unless -d $outdir;

    warn "NOTICE: copying configuration file and log file.\n";
    !system("cp -f $advanced $param_file") and !system("cp -f $log $log_file") or die "Failed to copy configuration or log file: $!\n";
    push @commands,{
	nCPU_requested	=>	1,
	message		=>	"Generating html report",
	command		=>	["$html_gen $outdir @prefix_list"],
	in		=>	[grep {$_->filetype eq 'STATS'} @obj_list],
	out		=>	[],
    };
}
#generate various stats used in reports
sub genStat {
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $seqmule=File::Spec->catfile($install_dir,"bin","seqmule");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my @per_sample_obj = grep {$_->sample() eq $sample} @obj_list;
	my $result_folder = &get_result_folder($sample);
	my ($qcstat,$stat_prefix);
	$stat_prefix=File::Spec->catfile($result_folder,$sample);
	$qcstat=$stat_prefix."_qc_stat.txt";

	#QC stat is handled at &fastqc subroutine
	#output venn diagram
	{
	    #we don't include consensus results as they are extracted from other VCFs
	    my @venn_obj = grep { $_->filetype eq 'VCF' and $_->caller ne 'consensus'} @per_sample_obj;
	    if(@venn_obj) {
		my $venn_stat_obj = $venn_obj[0]->clone();
		$venn_stat_obj->filetype('STATS');
		$venn_stat_obj->file("${stat_prefix}_venn.jpg"); #this obj is only used for resolving dependency
		$venn_stat_obj->parent(@venn_obj);
		map {$_->child($_->child,$venn_stat_obj)} @venn_obj;
		my $cmd_common = "$seqmule stats -tmpdir $TMPDIR ".
		#each VCF may contain multiple samples
		#sample names will match samples associated with obj for FASTQ/BAM with/without merging
		" -prefix $stat_prefix -ref $local_ref -s $sample ";

		if(@venn_obj <= 5 && @venn_obj >=2) {
		    push @commands,{
			nCPU_requested		=>	1,
			message			=>	"Generate Venn digram",
			command			=>	["$cmd_common -venn ".join(',',(map {$_->file()} @venn_obj))],
			in				=>	[@venn_obj],
			out				=>	[$venn_stat_obj],
		    };
		    push @obj_list,$venn_stat_obj;
		} else {
		    warn "WARNING: For each sample, there are >5 or <2 VCF files, no Venn diagram will be drawn.\n";
		}
	    }
	}
	#output alignment and coverage statistics
	#only output statistics about one BAM, can be improved later
	if (my ($bam_obj)=grep { $_->filetype eq 'BAM' } (@per_sample_obj)) {#only report one BAM 
	    my $bam = $bam_obj->file();
	    my $bam_stat_obj = $bam_obj->clone();
	    $bam_stat_obj->filetype('STATS');
	    $bam_stat_obj->file("${stat_prefix}_aln_stat.txt"); #this obj is only used for resolving dependency
	    $bam_stat_obj->parent($bam_obj);
	    $bam_obj->child($bam_obj->child,$bam_stat_obj);
	    warn "NOTICE: SeqMule only reports statistics from ONE BAM file.\n";
	    push @commands,{
		nCPU_requested			=>	1,
		message				=>	"Generate alignment and coverage stat",
		command				=>	["$seqmule stats -tmpdir $TMPDIR -bam $bam -aln -prefix $stat_prefix ".($wes?" -capture $capture ":"")],
		in				=>	[$bam_obj],
		out				=>	[$bam_stat_obj],
	    };
		push @obj_list,$bam_stat_obj;
	}
	#output variant statistics
	if (my @vcf_obj = grep { $_->filetype eq 'VCF' } (@per_sample_obj)) {
	    my @vcf = map{$_->file()} @vcf_obj;
	    my $var_stat_obj = $vcf_obj[0]->clone();
	    $var_stat_obj->filetype('STATS');
	    $var_stat_obj->file("${sample}_var_stat.txt"); #this obj is only used for resolving dependency
	    $var_stat_obj->parent(@vcf_obj);
	    map {$_->child($_->child,$var_stat_obj)} @vcf_obj;
	    my $genVarStat=File::Spec->catfile($install_dir,"bin/secondary/genVarStat");
	    push @commands,{
		nCPU_requested			=>	1,
		message				=>	"Generate variant stat",
		command				=>	["$genVarStat -s $sample $stat_prefix @vcf"],
		in				=>	[@vcf_obj],
		out				=>	[$var_stat_obj],
	    };
	    push @obj_list,$var_stat_obj;
	}
    }
}
sub mergeVCF
{
    #merge VCF because variants are called over different regions
    #under quick mode
    #all VCFs that are supposed to be merged into one VCF
    #are siblings to each other

    #first figure out what VCFs to merge (only include rank=0)
    my @vcf_to_merge_rank0;
    for my $vcf_obj(@obj_list) {
	next unless $vcf_obj->rank == 0 and 
	$vcf_obj->filetype eq 'VCF' and
	$vcf_obj->sibling > 1;
	push @vcf_to_merge_rank0,$vcf_obj;
    }

    for my $vcf_obj(@vcf_to_merge_rank0)
    {
	my @sibling_vcf_obj = ($vcf_obj,$vcf_obj->sibling());
	#if we decide to merge, remove the VCFs to be merged from VCF pool
	SeqMule::SeqUtils->rmObjFromArray(
	    target=>\@sibling_vcf_obj,
	    all=>\@obj_list,
	);
	my ($local_prefix) = $vcf_obj->file() =~ /(.*?)\.vcf$/i;
	my $merged_vcf_obj = $vcf_obj->clone();
	my $expect_merged_vcf_obj = $vcf_obj->clone();
	my $out_file="${local_prefix}_union.vcf"; #file content is correct, name isn't
	my $expect_out_file="$local_prefix.vcf"; #this is what we want

	$merged_vcf_obj->file($out_file);
	$merged_vcf_obj->parent(@sibling_vcf_obj);
	$expect_merged_vcf_obj->file($expect_out_file);
	$expect_merged_vcf_obj->parent($merged_vcf_obj);
	map {$_->child($merged_vcf_obj)} @sibling_vcf_obj;

	push @commands,{
	    nCPU_requested		=>	1,
	    message			=>	"Merge split VCF",
	    command			=>	[
		&vcf_merge_cmd_gen($local_prefix,map{$_->file()}@sibling_vcf_obj),
		"mv -f $out_file $expect_out_file",
	    ],
	    in				=>	[@sibling_vcf_obj],
	    out				=>	[$expect_merged_vcf_obj],
	};
	push @obj_list,$expect_merged_vcf_obj;
	#only siblings here!!, why?
	#the vcf_obj->file() will be used as name of merged VCF
	#so we need to keep it
	push @script_unlink_list,(map{$_->file()} $vcf_obj->sibling());
	push @script_unlink_list,(map {"$_.idx"} (map{$_->file()} @sibling_vcf_obj));
    }
}

sub getConsensusCall
{
    #merge vcfs by prefix (samplename)
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    #we regarde "consensus" as a calling method
    my $caller = "consensus";
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});
    my $cmd_common = "$exe stats -tmpdir $TMPDIR -ref $local_ref ".
    " -jmem $java_mem ".
    " -jexe $jexe ".
    " -t ".($threads>$gatk_nt? $gatk_nt:$threads); #use smaller one
    $cmd_common .= " -N $minN" if $minN;

    for my $sample(SeqMule::SeqUtils->get_attr_enum('sample',@obj_list)) {
	my @vcf_obj = grep {$_->sample eq $sample and $_->filetype eq 'VCF'} @obj_list;

	#at least 2 VCFs are required for each sample to get consensus
	next unless @vcf_obj>1;
	warn
	"WARNING: user requests to extract consensus calls from at least $minN files,\n",
	"WARNING: but there are only ",scalar(@vcf_obj)," files.\n" and next
	if $minN && @vcf_obj<$minN;

	my $outdir = &get_result_folder($sample);
	#this is used for seqmule stats command
	my $out_prefix = File::Spec->catfile($outdir,${sample}.($wes? ".extract":""));
	my $out = $out_prefix."_consensus.vcf";
	my $new_vcf_obj = $vcf_obj[0]->clone();

	$new_vcf_obj->caller($caller);
	$new_vcf_obj->parent(@vcf_obj);
	$new_vcf_obj->file($out);
	map {$_->child($new_vcf_obj) } @vcf_obj;


	my $cmd = $cmd_common;
	$cmd .= " -c-vcf ".join(",",
	    map{$_->file()} 
	    (sort 
		{ ($VARIANT_QUAL_PRIORITY_LIST{$a->caller} <=> 
			$VARIANT_QUAL_PRIORITY_LIST{$b->caller}) } 
		@vcf_obj)
	);
	$cmd .= " -p $out_prefix ";
	push @commands,{
	    nCPU_requested		=>	1,
	    message			=>	"Extract consensus calls",
	    command			=>	[$cmd],
	    in				=>	[@vcf_obj],
	    out				=>	[$new_vcf_obj],
	};
	push @obj_list,$new_vcf_obj;
	#right now we keep all VCFs
	#SeqMule::SeqUtils->rmObjFromArray(
	#    target=>\@vcf_obj,
	#    all=>\@obj_list,
	#);
    }
}

sub extractVar {
    #extract variants in BED region
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    my $cmd_common="$exe stats -tmpdir $TMPDIR ";
    $cmd_common .= " -capture $capture " if $wes;
    #1.vcf => 1.extract.vcf (seqmule stats default naming rule)
    for my $vcf_obj(@obj_list) {
	next unless $vcf_obj->filetype eq 'VCF';
	my $vcf = $vcf_obj->file();
	if ($vcf =~ /(.*)\.vcf$/i) {
	    my $local_prefix=$1;
	    my $out="$local_prefix.extract.vcf";
	    my $new_vcf_obj = $vcf_obj->clone();
	    $new_vcf_obj->file($out);
	    $new_vcf_obj->parent($vcf_obj);
	    $vcf_obj->child($new_vcf_obj);

	    my $cmd = $cmd_common;
	    $cmd .= " -vcf $vcf -p $local_prefix";
	    push @commands,{
		nCPU_requested		=>	1,
		message			=>	"Extract variants in custom regions",
		command			=>	[$cmd],
		in			=>	[$vcf_obj],
		out			=>	[$new_vcf_obj],
	    };
	    $vcf_obj = $new_vcf_obj;
	    push @removable,$vcf_obj;
	} else {
	    die "ERROR: Failed to get VCF prefix (*.vcf format expected): $vcf\n";
	}
    }
}
sub vcf_merge_cmd_gen {
    my $out_prefix=shift;
    my @vcf=@_;
    my $exe=File::Spec->catfile($install_dir,"bin","seqmule");
    my $local_ref=&SeqMule::Utils::search_db({type=>"ref",target=>$ref,build=>$buildver,install_dir=>$install_dir});

    my $cmd;

    $cmd=
    "$exe stats -tmpdir $TMPDIR -ref $local_ref".
    " -jmem $java_mem".
    " -jexe $jexe ".
    " -t ".($threads>$gatk_nt? $gatk_nt:$threads). #use smaller one
    " -u-vcf ".join(",",@vcf).
    " -p $out_prefix";

    return $cmd;
}
sub convert64to33 {
    my $exe=File::Spec->catfile($install_dir,"bin","secondary","phred64to33");
    if ($phred==64) {
	warn "before" if $debug;
	check_obj(@obj_list) if $debug;
	for my $i(@obj_list) {
	    next unless $i->filetype() eq 'FASTQ';
	    my $newobj = $i->clone();
	    my $file=$i->file();
	    $file =~ s/(.*)\.(fq|fastq|fastq\.gz|fq\.gz)$/${1}_phred33.$2/;
	    $newobj->file($file);
	    $newobj->parent($i);
	    #don't forget to set rank, it's reset to 0 during cloning
	    $newobj->rank($i->rank);
	    $i->child($newobj);

	    push @commands,{
		nCPU_requested		=>	1,
		message			=>	"Convert phred64 to phred33",
		command			=>	[join(" ",$exe,$i->file(),$newobj->file())],
	    	in			=>	[$i],
		out			=>	[$newobj],
	    };
	    $i = $newobj;
	    push @script_unlink_list,$newobj->file();
	}
	check_obj(@obj_list) if $debug;
	$phred=33;
	for my $i(@obj_list) {
	    #after cloning, sibling is still pointed to phred64 fastq
	    #we need to repoint sibling to old obj's child
	    $i->sibling(map{$_->child} $i->sibling());
	}
    }
}
sub merge_bam {
    my $onebam_obj = shift;
    my @other_bam_obj = @_;
    my @other_bam_file = map {$_->file()} @other_bam_obj;
    my $samtools=&getExe(&SeqMule::Utils::getProgramExe("samtools"));
    my $header_check=File::Spec->catfile($install_dir,"bin","secondary","sameBAMSQ");

    $onebam_obj->ancestor(@other_bam_obj);
    $onebam_obj->parent(@other_bam_obj);
    map { $_->child($onebam_obj) } @other_bam_obj;

    #force single sample in each BAM
    &checkBAMSample($samtools,@other_bam_obj);
    if ($force_one_rg) {
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMOneRG");
	push @commands, {
	    nCPU_requested		=>	$threads,
	    message			=>	"Merge BAM into one readgroup",
	    command			=>	
	    #readgroup has been changed before calling &merge_bam
	    #so no need to change it here
	    ["$exe $samtools $threads ".$onebam_obj->rg()." ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)],
	    in				=>	[@other_bam_obj],
	    out				=>	[$onebam_obj],
	};
    } elsif ($union_rg) {
	my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMUnionRG");
	#check READGROUP ID, they must be unique, o/w use '-forceOneRG' or '-unionRG'
	push @commands, {
	    nCPU_requested		=>	$threads,
	    message			=>	"Merge BAM without changing readgroup",
	    command			=>	["$exe $samtools $threads ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)],
	    in				=>	[@other_bam_obj],
	    out				=>	[$onebam_obj],
	};
    } else {
	#check READGROUP ID, they must be unique, o/w use '-forceOneRG' or '-unionRG'
	if (&SeqMule::Utils::checkDuplicateRGID($samtools,@other_bam_obj)) {
	    die "ERROR: SeqMule cannot decide how to merge BAM files with duplicate readgroup IDs. Please use '--forceOneRG' or '--unionRG' option.\n";
	} else {
	    my $exe=File::Spec->catfile($install_dir,"bin","secondary","mergeBAMUnionRG");
	    push @commands, {
		nCPU_requested		=>	$threads,
		message			=>	"Merge BAM without changing readgroup",
		command			=>	["$exe $samtools $threads ".$onebam_obj->file()." $TMPDIR ".join(" ",@other_bam_file)],
		in			=>	[@other_bam_obj],
		out			=>	[$onebam_obj],
	    };
	}
    }
}
sub writeScript {
    $script_file="${analysis_prefix}.script";
    warn "NOTICE: script file will be overwritten: $script_file\n" if -f $script_file;
    &SeqMule::Parallel::writeParallelCMD ({
	    worker=>File::Spec->catfile($install_dir,"bin","secondary","worker"),
	    file=>$script_file,
	    cpu_total=>$total_threads,
	    cmd=>\@commands,
	});
}
sub assignDefault {
    #assign default values for global options
    $threads=$threads || 1;
    $java_mem=$java_mem || '1750m';
    $jexe = $jexe || 'java';
    $gatk_nt=$gatk_nt || 2;
    $pl=$pl || 'ILLUMINA';
    $phred=$phred || 1;
    $rg=$rg || 'READGROUP';
    $lb=$lb || 'LIBRARY';
    $buildver=$buildver || 'hg19';
    $dbsnpver=$dbsnpver || 138;
    $TMPDIR = $TMPDIR || $ENV{TMPDIR} || "/tmp";
}
#######################HELPER SUBROUTINES#############################
sub get_result_folder {
    my $sample = shift;
    my $result_folder="${sample}_result";
    mkdir $result_folder unless -d $result_folder;
    return $result_folder;
}
sub getAlias {
    my $obj = shift;
    my $alias = join("_",(map {basename $_->file()} $obj->ancestor()));
    return $alias;
}
sub get_aligner {
    return SeqMule::SeqUtils->get_attr_enum('aligner',@obj_list);
}
sub check_obj { #show all attributes of objects, used for debug
    map {$_->dump()} @_;
    $|=1; #flush buffer
}
sub remove_obj_from_array { #remove obj in target from obj in all
    my $opt = shift @_;
    my $target = $opt->{target};
    my $all = $opt->{all};

    for my $i(@$target)
    {
	for my $j(@$all)
	{
	    if($i->id() == $j->id())
	    {
		$j = undef;
	    }
	}
    }
    @$all = grep {defined $_} @$all;
}
sub get_gatk_nt {
    my ($total,$gatk)=@_;
    if ($total>= $gatk) {
	return $gatk;
	warn "NOTICE: Set GATK genotype calling threads to $gatk for safety\n" if $total>1;
    } else {
	return $total;
    }
}
sub checkBAMSample {
    my $samtools=shift;
    my @bam_obj=@_;
    my $first_sample;

    warn "NOTICE: Checking sample names in BAM...\n";
    for (@bam_obj) {
	my @local_sample=&SeqMule::Utils::getBAMSample($samtools,$_->file());
	die "ERROR: One and only one sample allowed in each BAM, found @local_sample.\n" if @local_sample!=1;
	$first_sample=$local_sample[0] unless defined $first_sample;
	die "ERROR: Found two different sample names in BAM input when merging is enabled: $local_sample[0] $first_sample\n" if (defined $first_sample && $first_sample ne $local_sample[0] && $merge);
    }
}
sub getExe {
    for my $exename(@_) {
	if ($loc{$exename}) {
	    return $loc{$exename};
	} else {
	    if(my $exepath=&SeqMule::Utils::search($install_dir,$exename)) {
		$loc{$exename}=$exepath;
		return $exepath;
	    }
	}
    }
    die "ERROR: Failed to find @_\n";
}
#check if index files exist                        
sub index_check
{
    if ($no_check_aligner_index) {
	return 1;
    }
    my ($program,$prefix)=@_;

    if( $program=~/^soap$/i) {
	return
	(-e "$prefix.amb" && -e "$prefix.ann" && -e "$prefix.bwt" && -e "$prefix.fmv" && -e "$prefix.hot" && -e "$prefix.lkt" && -e "$prefix.pac" && -e "$prefix.rev.bwt" && -e "$prefix.rev.fmv" && -e "$prefix.rev.lkt" && -e "$prefix.rev.pac" && -e "$prefix.sa" && -e "$prefix.sai");

    } elsif ($program=~/^bowtie$/i) {
	return 
	(-e "$prefix.1.ebwt" && -e "$prefix.2.ebwt" && -e "$prefix.3.ebwt" && -e "$prefix.4.ebwt" && -e "$prefix.rev.1.ebwt" && -e "$prefix.rev.2.ebwt"); 

    } elsif ($program=~/^bowtie2$/i) {
	return
	(-e "$prefix.1.bt2" && -e "$prefix.2.bt2" && -e "$prefix.3.bt2" && -e "$prefix.4.bt2" && -e "$prefix.rev.1.bt2" && -e "$prefix.rev.2.bt2");

    } elsif ($program=~/^bwa|bwamem$/i)
    {
	return (-e "$prefix.amb" && -e  "$prefix.bwt" && -e "$prefix.pac" && -e "$prefix.ann" && -e "$prefix.fai" && -e "$prefix.sa");
    } elsif ($program=~/^snap$/i)
    {
	return (-e File::Spec->catfile($prefix,"Genome") && -e  File::Spec->catfile($prefix,"GenomeIndex") && -e File::Spec->catfile($prefix,"GenomeIndexHash") && -e File::Spec->catfile($prefix,"OverflowTable"));
    } else { die "Unrecognized program ($program) for index check\n"}
}
#######################END OF HELPER SUBROUTINES#############################


__END__


=head1 NAME

seqmule-pipeline generates an analysis script based on options and/or advanced configuration.

=head1 SYNOPSIS

	seqmule pipeline <options>

=head1 DESCRIPTION

This command takes FASTQ/BAM files, various options and an optional advanced configuration file as input and generates a script file containing a set of commands, along with their resource requirements and dependencies. The script will then be given to seqmule-run for execution unless otherwise directed.

=head1 OPTIONS

	--prefix,-p		  comma-delimited list of sample names, will be used for
				  output file naming. Mandatory for FASTQ input or BAM input
				  with merge enabled.

	-a <FASTQ>             	  1st FASTQ file (or comma-delimited list)
	-b <FASTQ>             	  2nd FASTQ file (or comma-delimited list)
	--bam <BAM>		  BAM file (or comma-delimited list). Exclusive of -a,-b 
				  options.
	-a2 <FASTQ>            	  1st FASTQ file (or comma-delimited list) from tumor tissue.
	-b2 <FASTQ>            	  2nd FASTQ file (or comma-delimited list) from tumor tissue.
	--bam2 <BAM>		  BAM file (or comma-delimited list) from tumor tissue. 
				  Exclusive of FASTQ input.

	--merge,-m		  merge FASTQ or BAM files before analysis
	--mergingrule <TEXT>	  comma-delimited numbers for how many files merged for 
				  each sample.
				  Default: equal number of files for each samples.
	-ms			  do multiple-sample variant calling (only valid for GATK
				  ,VarScan and SAMtools)

	-N <INT>		  if more than one set of variants are generated, extract
				  variants shared by at least INT VCF output
	--build <hg18,hg19>	  genome build. Default is hg19.
	--readgroup,-rg <TEXT>    readgroup ID. Specify one ID for all input or a comma-
				  separated list. Default: READGROUP_[SAMPLE NAME]
	--platform,-pl <TEXT>	  sequencing platform, only Illumina and IonTorrent are 
				  supported. Specify one platform for all input or a comma-
				  separated list. Only for FASTQ input. Default: ILLUMINA.
	--library,-lb <TEXT>	  sequencing library. Specify one library for all input or 
				  a comma-separated list. Only for FASTQ input. Default:
				  LIBRARY.
	--forceOneRG		  force use of one readgroup ID for BAM when merging is 
				  enabled. See details.
	--unionRG		  When merging BAM files, combine reads with same readgroup 
				  ID, keep reads with different readgroup IDs intact.
	--phred <1,33,64>	  Phred score scheme. 1 is default, for auto-detection. 
				  Has no effect on BAM input.
	--wes,-e                  the input is captured sequencing data
	--wgs,-g		  the input is whole-genome sequencing data
	--capture <BED>		  calculate coverage stats and extract (or call) variants
				  over the regions defined by this file. If you do not have
				  a custom BED file, use '-capture default' to use default
				  BED file.
	--no-resolve-conflict	  seqmule will NOT try to resolve any conflict among BED,
				  BAM and reference. Run 'seqmule pipeline -h' for details.
	--no-check-chr		  skip checking chromosome consistency. By default, SeqMule
				  forces chromosomes in input to be consistent with builtin
				  reference.
        --no-check-idx		  skip checking index files for aligners. This is recommended
				  when using non-default reference genome.
	--threads,-t <INT>	  number of threads, also effective for -sge. Default: 1.
      	--sge <TEXT>		  run each command via Sun Grid Engine. A template with 
				  XCPUX keyword required. See examples.
	--nodeCapacity,-nc <INT>  max number of processes/threads for a single node/host.
				  Default: unlimited.
	--quick,-q		  enable parallel processing at variant calling
	--jmem <STRING>		  max memory used for java virtual machine. Default: 1750m.
	--jexe <STRING>		  Java executable path. Default: java
	--gatknt <INT>		  number of threads for GATK. Prevent GATK from opening 
				  too many files. Default: 2.
	--advanced [FILE]	  generate or use an advanced configuration file
	--tmpdir <DIR>		  use DIR for storing large temporary files. Default: 
				  $TMPDIR(in your ENV variables) or /tmp
	--norun,-nr		  do NOT run analysis, only generate script
	--nostat,-ns 		  do NOT generate statistics
	--norm			  do NOT remove intermediate SAM, BAM and other files
	--forceRmDup		  force removal of duplicates. This overrides default 
				  behavior which disables duplicate removal for small capture regions.
	--overWrite,-ow		  overwrite files whose names conflict with current analysis.

	--ref <FILE>              reference genome. Override default database (the following
				  is the same). 
				  When you use custom databases, make sure they are 
				  compatible with each other.
	--index <PREFIX>          prefix for bowtie, bowtie2, soap index files. Including 
				  path.
	--bowtie <PREFIX>         prefix ONLY for bowtie index files, including path
	--bowtie2 <PREFIX>        prefix only for bowtie2 index files, including path
	--soap <PREFIX>           prefix only for soap index files, including path
	--hapmap <FILE>           HapMap VCF file for variant quality recalibration
	--dbsnp <FILE>            dbSNP VCF file for variant quality recalibration
	--dbsnpver,-dv <INT>      dbSNP version for variant quality recalibration. By 
				  default, it's 138.
	--kg <FILE>               1000 genome project VCF file for variant quality 
	 			  recalibration
	--indel <FILE>		  Indel VCF file for GATK realignment and VQSR

	--verbose,-v		  verbose output
	--help,-h		  show this message

=head1 EXAMPLES


	###Typical exome analysis
	Scenario: I sequenced an exome (with four `FASTQ` files) by nimblegen v3 array, and I want to call the variants by BWA+GATK. Assume you have [downloaded](#Download all hg19 databases/`BED`s). Analyze the data by the following command:
	
		seqmule pipeline -a sample_lane1_R1.fq.gz,sample_lane2_R1.fq.gz -b sample_lane1_R2.fq.gz,sample_lane2_R2.fq.gz -capture seqmule/database/hg19nimblegen/hg19_nimblegen_SeqCap_exome_v3.bed -m -e -advanced seqmule/misc/predefined_config/bwa_gatk_HaplotypeCaller.config -quick -t 4 -prefix mySample
	
	Explanations: `-quick` enables faster variant calling at the expense of higher memory usage; `-t 4` tells SeqMule to use 4 CPUs; `-e` for exome or captured sequencing analysis; `-m` for merging two sets of reads.
	
	###Fast turnaround whole genome analysis
	Scenario: I sequenced a genome with 30X and I need the variant ASAP. The combination of SNAP+FreeBayes is usually pretty fast. The following command uses this combination to perform analysis:
	
		seqmule pipeline -a sample_R1.fq.gz -b sample_R2.fq.gz -advanced seqmule/misc/predefined_config/snap_freebayes.config -quick -t 12 -g -prefix mySample
	
	Explanations: `-g` for whole genome analysis; `-t 12` asks SeqMule to use 12 CPUs; `-quick` enables faster variant calling at the expense of higher memory usage. Note, SNAP is very memory-consuming, for best reliability, please make sure to have at least *32GB* memory. Reducing number of CPUs will decrease memory a little bit.
	
	###Trio exome analysis
	Scenario: I sequenced a family trio by exome and I want to find disease-causing (e.g. de novo) variants. I want to use SGE for this analysis.
	
		seqmule pipeline -a fa_R1.fq.gz,mo_R1.fq.gz,son_R1.fq.gz -b fa_R2.fq.gz,mo_R2.fq.gz,son_R2.fq.gz -ms -e -q -t 36 -prefix father,mother,son -capture default -sge "qsub -V -cwd -pe smp XCPUX" -nc 12
	
	Explanations: `-e` for whole-exome or captured sequencing; `-ms` for multi-sample variant calling, which more accurate for a family trio than separate variant calling; `-capture default` tells SeqMule to use [default exome definition](/Miscellaneous/FAQ.md# How are default exome regions defined? Where do they come from?) for extracting variants; `-sge "qsub -V -cwd -pe smp XCPUX` tells SeqMule proper SGE commands and options for job submission, in particular, `XCPUX` is a special keyword reserved for SeqMule to specify number of CPUs for each job; `-q` enables faster variant calling at the expense of higher memory usage; `-prefix father,mother,son` specifies 3 prefixes for 3 sets of reads; `-t 36` asks SeqMule to use 36 CPUs, in a cluster environment, these CPUs might no reside on the same machine; `-nc 12` tells SeqMule that a compute node has at most 12 CPUs. By default, the combination of BWA-MEM+FreeBayes+SAMtools+GATKLite will be used for analysis. A consensus VCF file (from 3 variant callers) will be generated at the end.

=head1 DETAILS

=over 8

=item B<--sge>

To run commands via Sun Grid Engine, SGE must be installed first. -e, -o will be added automatically. "-S /bin/bash" is added automatically. Do NOT specify -e,-o or -S in the qsub template. -V, -cwd, -pe options must be present.

=item B<--platform>

sequencing platform, default is illumina. Only IonTorrent and Illumina are supported currently

=item B<--ref>

specify the reference genome, otherwise it searches inside installation path for default reference genome

=item B<--index>

specify prefix for index files, if a program-specific index prefix is supplied, this option will be omitted. If no index prefix is supplied, downloaded files will be searched for index

=item B<--rg>

Specify the readgroup of '@RG' tag in SAM/BAM file. Usually one combination of sample/library/lane constitutes a readgroup, but users can make their own choices. Default is 'READGROUP'.

=item B<--forceOneRG>

Force all readgroups to be one readgroup when merging is enabled. Some algorithms account for different variabiliy associated with reads from the different readgroups. This option is only effective for BAM input.

=item B<--unionRG>

When merging BAM files, combine reads with same readgroup ID, keep reads with different readgroup IDs intact.

=item B<--mergingrule>

comma-delimited numbers for how many files merged for each sample. For example, if your prefix list is sample1,sample2, and mergingrule is 2,3, then the first 2 input files are merged as sample1 and the last 3 files are merged as sample2. Positive integers are expected. Default: equal number of files for each samples. So if you have two samples and 4 fastq/bam files, then the first two are merged for 1st sample, the last two are merged for 2nd sample.

=item B<--hapmap>

specify the HapMap VCF file for variant quality recalibration, otherwise it searches for default file within installation directory

=item B<--dbsnp>

specify the dbSNP file for variant quality recalibration, otherwise it searches for default file within installation directory

=item B<--kg>

specify the 1000 genome project VCF file for variant quality recalibration, otherwise it searches for default file inside installation directory

=item B<--no-resolve-conflict>

By default, SeqMule will add or trim leading 'chr' to the BED file or BAM file to make the contig names consistent with reference. Modified BED and BAM will be saved to a new file.

=back

=cut
